// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_i32_ptr_usize_2_bool {
    int32_t _0;
    const void* _1;
    uintptr_t _2;
    bool _3;
    bool _4;
};

struct _ffi_ret_ptr_usize {
    const void* _0;
    uintptr_t _1;
};

extern "C" {

void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_ptr_usize _ffi_fn_check_nested(int32_t x);
_ffi_ret_i32_ptr_usize_2_bool _ffi_fn_get_tree();
uintptr_t _ffi_fn_rust_mem_leaked();

} // extern "C"

namespace {

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

std::unique_ptr<int32_t> _ffi_box_i32_from_rust(const uint8_t*& end) {
    auto val = _ffi_read<int32_t>(end);
    return std::make_unique<int32_t>(val);
}

std::unique_ptr<std::unique_ptr<int32_t>> _ffi_box_box_i32_from_rust(const uint8_t*& end) {
    auto val = _ffi_box_i32_from_rust(end);
    return std::make_unique<std::unique_ptr<int32_t>>(std::move(val));
}

std::unique_ptr<std::unique_ptr<std::unique_ptr<int32_t>>> _ffi_box_box_box_i32_from_rust(const uint8_t*& end) {
    auto val = _ffi_box_box_i32_from_rust(end);
    return std::make_unique<std::unique_ptr<std::unique_ptr<int32_t>>>(std::move(val));
}

std::unique_ptr<rust::Tree> _ffi_box_Tree_from_rust(const uint8_t*& end);

std::unique_ptr<rust::Tree> _ffi_box_Tree_from_rust(const uint8_t*& end) {
    auto val_value = _ffi_read<int32_t>(end);
    auto val_left = _ffi_read<bool>(end) ? std::make_optional(_ffi_box_Tree_from_rust(end)) : std::nullopt;
    auto val_right = _ffi_read<bool>(end) ? std::make_optional(_ffi_box_Tree_from_rust(end)) : std::nullopt;
    auto val = rust::Tree{val_value, std::move(val_left), std::move(val_right)};
    return std::make_unique<rust::Tree>(std::move(val));
}

} // namespace

bool rust::Nested::operator == (const rust::Nested& n) const {
    return ***_0 == ***n._0;
}

bool rust::Tree::operator == (const rust::Tree& t) const {
    return (
        value == t.value &&
        (left && t.left ? **left == **t.left : !left && !t.left) &&
        (right && t.right ? **right == **t.right : !right && !t.right)
    );
}

rust::Nested rust::check_nested(int32_t x) {
    auto multi_ret = _ffi_fn_check_nested(x);
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret_0 = _ffi_box_box_box_i32_from_rust(buf_end);
    auto ret = rust::Nested{std::move(ret_0)};
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

rust::Tree rust::get_tree() {
    auto multi_ret = _ffi_fn_get_tree();
    auto ret_value = multi_ret._0;
    auto buf_ptr = multi_ret._1;
    auto buf_cap = multi_ret._2;
    auto has_ret_left = multi_ret._3;
    auto has_ret_right = multi_ret._4;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret_left = has_ret_left ? std::make_optional(_ffi_box_Tree_from_rust(buf_end)) : std::nullopt;
    auto ret_right = has_ret_right ? std::make_optional(_ffi_box_Tree_from_rust(buf_end)) : std::nullopt;
    auto ret = rust::Tree{ret_value, std::move(ret_left), std::move(ret_right)};
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}
