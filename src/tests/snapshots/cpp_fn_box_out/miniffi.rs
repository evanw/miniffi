// This file was generated by miniffi v0.1.0. Do not edit.

#[allow(non_snake_case)]
fn _ffi_box_Tree_to_cpp(val: Tree, buf: &mut Vec<u8>) {
    _ffi_write(val.value, buf);
    _ffi_write(val.left.is_some(), buf);
    if let Some(val_left_val) = val.left {
        _ffi_box_Tree_to_cpp(*val_left_val, buf);
    }
    _ffi_write(val.right.is_some(), buf);
    if let Some(val_right_val) = val.right {
        _ffi_box_Tree_to_cpp(*val_right_val, buf);
    }
}

fn _ffi_box_box_box_i32_to_cpp(val: Box<Box<i32>>, buf: &mut Vec<u8>) {
    _ffi_box_box_i32_to_cpp(*val, buf);
}

fn _ffi_box_box_i32_to_cpp(val: Box<i32>, buf: &mut Vec<u8>) {
    _ffi_box_i32_to_cpp(*val, buf);
}

fn _ffi_box_i32_to_cpp(val: i32, buf: &mut Vec<u8>) {
    _ffi_write(val, buf);
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_check_nested(x: i32) -> _ffi_ret_ptr_usize {
    let ret = check_nested(x);
    let ret_0 = ret.0;
    let mut buf = Vec::<u8>::new();
    _ffi_box_box_box_i32_to_cpp(*ret_0, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    _ffi_ret_ptr_usize(buf_ptr, buf_cap)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_get_tree() -> _ffi_ret_i32_ptr_usize_2_bool {
    let ret = get_tree();
    let ret_value = ret.value;
    let ret_left = ret.left;
    let mut buf = Vec::<u8>::new();
    let has_ret_left = ret_left.is_some();
    if let Some(ret_left_val) = ret_left {
        _ffi_box_Tree_to_cpp(*ret_left_val, &mut buf);
    }
    let ret_right = ret.right;
    let has_ret_right = ret_right.is_some();
    if let Some(ret_right_val) = ret_right {
        _ffi_box_Tree_to_cpp(*ret_right_val, &mut buf);
    }
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    _ffi_ret_i32_ptr_usize_2_bool(ret_value, buf_ptr, buf_cap, has_ret_left, has_ret_right)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[repr(C)]
struct _ffi_ret_i32_ptr_usize_2_bool(i32, *const u8, usize, bool, bool);

#[repr(C)]
struct _ffi_ret_ptr_usize(*const u8, usize);

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = &raw const val as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}
