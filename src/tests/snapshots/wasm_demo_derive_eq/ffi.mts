// This file was generated by miniffi v0.1.0. Do not edit.

export async function instantiate(bytes: BufferSource, imports?: WebAssembly.ModuleImports): Promise<{ memory: WebAssembly.Memory }> {
    let env = Object.assign({}, imports, _ffi_imports);
    let promise = WebAssembly.instantiate(bytes, { env });
    _ffi_exports = (await promise).instance.exports as any;
    return { memory: _ffi_exports.memory };
}

export async function instantiateStreaming(source: Response | PromiseLike<Response>, imports?: WebAssembly.ModuleImports): Promise<{ memory: WebAssembly.Memory }> {
    let env = Object.assign({}, imports, _ffi_imports);
    let promise = WebAssembly.instantiateStreaming(source, { env });
    _ffi_exports = (await promise).instance.exports as any;
    return { memory: _ffi_exports.memory };
}

export type EnumBoxTup =
    | { readonly $: "Foo", 0: [number, number] }
    | { readonly $: "Bar" }
    | { readonly $: "Baz", x: number, y: number }

export type EnumVecTup =
    | { readonly $: "Foo", 0: [number, number][] }
    | { readonly $: "Bar" }
    | { readonly $: "Baz", x: number, y: number }

export type EnumOptTup =
    | { readonly $: "Foo", 0: [number, number] | null }
    | { readonly $: "Bar" }
    | { readonly $: "Baz", x: number, y: number }

export interface EmptyStruct {
}

export interface BoxTup0 {
    0: undefined,
}

export interface BoxTup1 {
    0: [number],
}

export interface BoxTup2 {
    0: [number, number],
}

export interface VecTup0 {
    0: undefined[],
}

export interface VecTup1 {
    0: [number][],
}

export interface VecTup2 {
    0: [number, number][],
}

export interface OptTup0 {
    0: undefined | null,
}

export interface OptTup1 {
    0: [number] | null,
}

export interface OptTup2 {
    0: [number, number] | null,
}

export interface TupBox {
    0: [number, boolean],
}

export interface VecBox {
    0: number[],
}

export interface BoxVec {
    0: number[],
}

export interface OptBox {
    0: number | null,
}

export interface BoxOpt {
    0: number | null,
}

export interface VecBoxVec {
    0: number[][],
}

export interface BoxVecBox {
    0: number[],
}

export interface OptBoxOpt {
    0: number | null,
}

export interface BoxOptBox {
    0: number | null,
}

export function rust_mem_leaked(): number {
    return _ffi_exports._ffi_fn_rust_mem_leaked();
}

export function empty_tuple(x: undefined): undefined {
    _ffi_exports._ffi_fn_empty_tuple();
    return undefined;
}

export function empty_struct(x: EmptyStruct): EmptyStruct {
    _ffi_exports._ffi_fn_empty_struct();
    return {};
}

export function box_tup_0(x: BoxTup0): BoxTup0 {
    let buf = _ffi_new_WriteBuf();
    _ffi_box__to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_tup_0(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxTup0 = { 0: _ffi_box__from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_tup_1(x: BoxTup1): BoxTup1 {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_tup_1(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxTup1 = { 0: _ffi_box_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_tup_2(x: BoxTup2): BoxTup2 {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_i32_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_tup_2(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxTup2 = { 0: _ffi_box_i32_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_tup_0(x: VecTup0): VecTup0 {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec__to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_tup_0(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: VecTup0 = { 0: _ffi_vec__from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_tup_1(x: VecTup1): VecTup1 {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_tup_1(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: VecTup1 = { 0: _ffi_vec_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_tup_2(x: VecTup2): VecTup2 {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_i32_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_tup_2(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: VecTup2 = { 0: _ffi_vec_i32_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_tup_0(x: OptTup0): OptTup0 {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_tup_0(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: OptTup0 = { 0: has_ret_0 ? undefined : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_tup_1(x: OptTup1): OptTup1 {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_write_i32(buf, x_0_val[0]);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_tup_1(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: OptTup1 = { 0: has_ret_0 ? [_ffi_read_i32(buf2)] : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_tup_2(x: OptTup2): OptTup2 {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_write_i32(buf, x_0_val[0]);
        _ffi_write_i32(buf, x_0_val[1]);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_tup_2(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: OptTup2 = { 0: has_ret_0 ? [_ffi_read_i32(buf2), _ffi_read_i32(buf2)] : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function enum_box_tup(x: EnumBoxTup): EnumBoxTup {
    let buf = _ffi_new_WriteBuf();
    _ffi_enum_EnumBoxTup_to_rust(x, buf);
    let multi_ret = _ffi_exports._ffi_fn_enum_box_tup(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: EnumBoxTup = _ffi_enum_EnumBoxTup_from_rust(buf2);
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function enum_vec_tup(x: EnumVecTup): EnumVecTup {
    let buf = _ffi_new_WriteBuf();
    _ffi_enum_EnumVecTup_to_rust(x, buf);
    let multi_ret = _ffi_exports._ffi_fn_enum_vec_tup(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: EnumVecTup = _ffi_enum_EnumVecTup_from_rust(buf2);
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function enum_opt_tup(x: EnumOptTup): EnumOptTup {
    let buf = _ffi_new_WriteBuf();
    _ffi_enum_EnumOptTup_to_rust(x, buf);
    let multi_ret = _ffi_exports._ffi_fn_enum_opt_tup(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: EnumOptTup = _ffi_enum_EnumOptTup_from_rust(buf2);
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function tup_box(x: TupBox): TupBox {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_i32_to_rust2(x[0][0], buf);
    _ffi_box_bool_to_rust(x[0][1], buf);
    let multi_ret = _ffi_exports._ffi_fn_tup_box(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: TupBox = { 0: [_ffi_box_i32_from_rust2(buf2), _ffi_box_bool_from_rust(buf2)] };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_box(x: VecBox): VecBox {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_box(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: VecBox = { 0: _ffi_vec_box_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_vec(x: BoxVec): BoxVec {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_vec_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_vec(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxVec = { 0: _ffi_box_vec_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_box(x: OptBox): OptBox {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_box_i32_to_rust2(x_0_val, buf);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_box(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: OptBox = { 0: has_ret_0 ? _ffi_box_i32_from_rust2(buf2) : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_opt(x: BoxOpt): BoxOpt {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_option_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_opt(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxOpt = { 0: _ffi_box_option_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_box_vec(x: VecBoxVec): VecBoxVec {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_box_vec_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_box_vec(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: VecBoxVec = { 0: _ffi_vec_box_vec_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_vec_box(x: BoxVecBox): BoxVecBox {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_vec_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_vec_box(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxVecBox = { 0: _ffi_box_vec_box_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_box_opt(x: OptBoxOpt): OptBoxOpt {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_box_option_i32_to_rust(x_0_val, buf);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_box_opt(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: OptBoxOpt = { 0: has_ret_0 ? _ffi_box_option_i32_from_rust(buf2) : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_opt_box(x: BoxOptBox): BoxOptBox {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_option_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_opt_box(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret: BoxOptBox = { 0: _ffi_box_option_box_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

let _ffi_dv: DataView;
let _ffi_new_ReadBuf = (off: number): _ffi_ReadBuf => ({ dv: _ffi_update_dv(), off });
let _ffi_new_WriteBuf = (): _ffi_WriteBuf => ({ u8: new Uint8Array(16), dv: null, off: 0 });
let _ffi_u8: Uint8Array;
let _ffi_enum_EnumBoxTup__Bar: EnumBoxTup = { $: "Bar" };
let _ffi_enum_EnumOptTup__Bar: EnumOptTup = { $: "Bar" };
let _ffi_enum_EnumVecTup__Bar: EnumVecTup = { $: "Bar" };

interface _ffi_ReadBuf {
    dv: DataView,
    off: number,
}

function _ffi_update_dv(): DataView {
    let buffer = _ffi_exports.memory.buffer;
    if (!_ffi_dv || _ffi_dv.buffer !== buffer) _ffi_dv = new DataView(buffer);
    return _ffi_dv;
}

interface _ffi_WriteBuf {
    u8: Uint8Array,
    dv: DataView | null,
    off: number,
}

function _ffi_box__from_rust(buf: _ffi_ReadBuf): undefined {
    return undefined;
}

function _ffi_box__to_rust(val: undefined, buf: _ffi_WriteBuf): void {
}

function _ffi_box_bool_from_rust(buf: _ffi_ReadBuf): boolean {
    return !!_ffi_read_u8(buf);
}

function _ffi_box_bool_to_rust(val: boolean, buf: _ffi_WriteBuf): void {
    _ffi_write_i8(buf, +val);
}

function _ffi_box_i32_from_rust(buf: _ffi_ReadBuf): [number] {
    return [_ffi_read_i32(buf)];
}

function _ffi_box_i32_from_rust2(buf: _ffi_ReadBuf): number {
    return _ffi_read_i32(buf);
}

function _ffi_box_i32_i32_from_rust(buf: _ffi_ReadBuf): [number, number] {
    return [_ffi_read_i32(buf), _ffi_read_i32(buf)];
}

function _ffi_box_i32_i32_to_rust(val: [number, number], buf: _ffi_WriteBuf): void {
    _ffi_write_i32(buf, val[0]);
    _ffi_write_i32(buf, val[1]);
}

function _ffi_box_i32_to_rust(val: [number], buf: _ffi_WriteBuf): void {
    _ffi_write_i32(buf, val[0]);
}

function _ffi_box_i32_to_rust2(val: number, buf: _ffi_WriteBuf): void {
    _ffi_write_i32(buf, val);
}

function _ffi_box_option_box_i32_from_rust(buf: _ffi_ReadBuf): number | null {
    return _ffi_read_u8(buf) ? _ffi_box_i32_from_rust2(buf) : null;
}

function _ffi_box_option_box_i32_to_rust(val: number | null, buf: _ffi_WriteBuf): void {
    _ffi_write_i8(buf, +(val !== null));
    if (val !== null) {
        let val_val = val;
        _ffi_box_i32_to_rust2(val_val, buf);
    }
}

function _ffi_box_option_i32_from_rust(buf: _ffi_ReadBuf): number | null {
    return _ffi_read_u8(buf) ? _ffi_read_i32(buf) : null;
}

function _ffi_box_option_i32_to_rust(val: number | null, buf: _ffi_WriteBuf): void {
    _ffi_write_i8(buf, +(val !== null));
    if (val !== null) {
        _ffi_write_i32(buf, val);
    }
}

function _ffi_box_vec_box_i32_from_rust(buf: _ffi_ReadBuf): number[] {
    return _ffi_vec_box_i32_from_rust(_ffi_read_u32(buf), buf);
}

function _ffi_box_vec_box_i32_to_rust(val: number[], buf: _ffi_WriteBuf): void {
    _ffi_write_i32(buf, val.length);
    _ffi_vec_box_i32_to_rust(val, buf);
}

function _ffi_box_vec_i32_from_rust(buf: _ffi_ReadBuf): number[] {
    return _ffi_vec_i32_from_rust2(_ffi_read_u32(buf), buf);
}

function _ffi_box_vec_i32_to_rust(val: number[], buf: _ffi_WriteBuf): void {
    _ffi_write_i32(buf, val.length);
    _ffi_vec_i32_to_rust2(val, buf);
}

function _ffi_update_u8(): Uint8Array {
    let buffer = _ffi_exports.memory.buffer;
    if (!_ffi_u8 || _ffi_u8.buffer !== buffer) _ffi_u8 = new Uint8Array(buffer);
    return _ffi_u8;
}

function _ffi_buf_to_rust({ u8, off }: _ffi_WriteBuf): number {
    let ptr = _ffi_exports._ffi_alloc(off);
    _ffi_update_u8().set(u8.length > off ? u8.subarray(0, off) : u8, ptr);
    return ptr;
}

function _ffi_enum_EnumBoxTup_from_rust(buf: _ffi_ReadBuf): EnumBoxTup {
    switch (_ffi_read_i32(buf)) {
        case 0: return { $: "Foo", 0: _ffi_box_i32_i32_from_rust(buf) };
        case 1: return _ffi_enum_EnumBoxTup__Bar;
        case 2: return { $: "Baz", x: _ffi_read_i32(buf), y: _ffi_read_i32(buf) };
        default: throw Error();
    }
}

function _ffi_enum_EnumBoxTup_to_rust(val: EnumBoxTup, buf: _ffi_WriteBuf): void {
    switch (val.$) {
        case "Foo":
            _ffi_write_i32(buf, 0);
            _ffi_box_i32_i32_to_rust(val[0], buf);
            break;
        case "Bar":
            _ffi_write_i32(buf, 1);
            break;
        case "Baz":
            _ffi_write_i32(buf, 2);
            _ffi_write_i32(buf, val.x);
            _ffi_write_i32(buf, val.y);
            break;
        default:
            throw TypeError("Invalid value for enum \"EnumBoxTup\"");
    }
}

function _ffi_enum_EnumOptTup_from_rust(buf: _ffi_ReadBuf): EnumOptTup {
    switch (_ffi_read_i32(buf)) {
        case 0: return { $: "Foo", 0: _ffi_read_u8(buf) ? [_ffi_read_i32(buf), _ffi_read_i32(buf)] : null };
        case 1: return _ffi_enum_EnumOptTup__Bar;
        case 2: return { $: "Baz", x: _ffi_read_i32(buf), y: _ffi_read_i32(buf) };
        default: throw Error();
    }
}

function _ffi_enum_EnumOptTup_to_rust(val: EnumOptTup, buf: _ffi_WriteBuf): void {
    switch (val.$) {
        case "Foo":
            _ffi_write_i32(buf, 0);
            _ffi_write_i8(buf, +(val[0] !== null));
            if (val[0] !== null) {
                let x_val = val[0];
                _ffi_write_i32(buf, x_val[0]);
                _ffi_write_i32(buf, x_val[1]);
            }
            break;
        case "Bar":
            _ffi_write_i32(buf, 1);
            break;
        case "Baz":
            _ffi_write_i32(buf, 2);
            _ffi_write_i32(buf, val.x);
            _ffi_write_i32(buf, val.y);
            break;
        default:
            throw TypeError("Invalid value for enum \"EnumOptTup\"");
    }
}

function _ffi_enum_EnumVecTup_from_rust(buf: _ffi_ReadBuf): EnumVecTup {
    switch (_ffi_read_i32(buf)) {
        case 0: return { $: "Foo", 0: _ffi_vec_i32_i32_from_rust(_ffi_read_u32(buf), buf) };
        case 1: return _ffi_enum_EnumVecTup__Bar;
        case 2: return { $: "Baz", x: _ffi_read_i32(buf), y: _ffi_read_i32(buf) };
        default: throw Error();
    }
}

function _ffi_enum_EnumVecTup_to_rust(val: EnumVecTup, buf: _ffi_WriteBuf): void {
    switch (val.$) {
        case "Foo":
            _ffi_write_i32(buf, 0);
            _ffi_write_i32(buf, val[0].length);
            _ffi_vec_i32_i32_to_rust(val[0], buf);
            break;
        case "Bar":
            _ffi_write_i32(buf, 1);
            break;
        case "Baz":
            _ffi_write_i32(buf, 2);
            _ffi_write_i32(buf, val.x);
            _ffi_write_i32(buf, val.y);
            break;
        default:
            throw TypeError("Invalid value for enum \"EnumVecTup\"");
    }
}

function _ffi_read_i32(buf: _ffi_ReadBuf): number {
    let val = buf.dv.getInt32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_u32(buf: _ffi_ReadBuf): number {
    let val = buf.dv.getUint32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_u8(buf: _ffi_ReadBuf): number {
    return buf.dv.getUint8(buf.off++);
}

function _ffi_vec__from_rust(len: number, buf: _ffi_ReadBuf): undefined[] {
    let items: undefined[] = [];
    while (items.length < len) {
        items.push(undefined);
    }
    return items;
}

function _ffi_vec__to_rust(items: undefined[], buf: _ffi_WriteBuf): void {
}

function _ffi_vec_box_i32_from_rust(len: number, buf: _ffi_ReadBuf): number[] {
    let items: number[] = [];
    while (items.length < len) {
        items.push(_ffi_box_i32_from_rust2(buf));
    }
    return items;
}

function _ffi_vec_box_i32_to_rust(items: number[], buf: _ffi_WriteBuf): void {
    for (const item of items) {
        _ffi_box_i32_to_rust2(item, buf);
    }
}

function _ffi_vec_box_vec_i32_from_rust(len: number, buf: _ffi_ReadBuf): number[][] {
    let items: number[][] = [];
    while (items.length < len) {
        items.push(_ffi_box_vec_i32_from_rust(buf));
    }
    return items;
}

function _ffi_vec_box_vec_i32_to_rust(items: number[][], buf: _ffi_WriteBuf): void {
    for (const item of items) {
        _ffi_box_vec_i32_to_rust(item, buf);
    }
}

function _ffi_vec_i32_from_rust(len: number, buf: _ffi_ReadBuf): [number][] {
    let items: [number][] = [];
    while (items.length < len) {
        items.push([_ffi_read_i32(buf)]);
    }
    return items;
}

function _ffi_vec_i32_from_rust2(len: number, buf: _ffi_ReadBuf): number[] {
    let items: number[] = [];
    while (items.length < len) {
        items.push(_ffi_read_i32(buf));
    }
    return items;
}

function _ffi_vec_i32_i32_from_rust(len: number, buf: _ffi_ReadBuf): [number, number][] {
    let items: [number, number][] = [];
    while (items.length < len) {
        items.push([_ffi_read_i32(buf), _ffi_read_i32(buf)]);
    }
    return items;
}

function _ffi_vec_i32_i32_to_rust(items: [number, number][], buf: _ffi_WriteBuf): void {
    for (const item of items) {
        _ffi_write_i32(buf, item[0]);
        _ffi_write_i32(buf, item[1]);
    }
}

function _ffi_vec_i32_to_rust(items: [number][], buf: _ffi_WriteBuf): void {
    for (const item of items) {
        _ffi_write_i32(buf, item[0]);
    }
}

function _ffi_vec_i32_to_rust2(items: number[], buf: _ffi_WriteBuf): void {
    for (const item of items) {
        _ffi_write_i32(buf, item);
    }
}

function _ffi_grow(buf: _ffi_WriteBuf, n: number): number {
    let off = buf.off;
    let u8 = buf.u8;
    if (off + n > u8.length) {
        (buf.u8 = new Uint8Array((off + n) << 1)).set(u8);
        buf.dv = null;
    }
    buf.off += n;
    if (!buf.dv) buf.dv = new DataView(buf.u8.buffer);
    return off;
}

function _ffi_write_i32(buf: _ffi_WriteBuf, val: number): void {
    let ptr = _ffi_grow(buf, 4);
    buf.dv!.setInt32(ptr, val, true);
}

function _ffi_write_i8(buf: _ffi_WriteBuf, val: number): void {
    let ptr = _ffi_grow(buf, 1);
    buf.dv!.setInt8(ptr, val);
}

let _ffi_exports: {
    memory: WebAssembly.Memory,
    _ffi_dealloc: (ptr: number, capacity: number) => void,
    _ffi_fn_box_opt: (buf_ptr: number) => number,
    _ffi_fn_box_opt_box: (buf_ptr: number) => number,
    _ffi_fn_box_tup_0: (buf_ptr: number) => number,
    _ffi_fn_box_tup_1: (buf_ptr: number) => number,
    _ffi_fn_box_tup_2: (buf_ptr: number) => number,
    _ffi_fn_box_vec: (buf_ptr: number) => number,
    _ffi_fn_box_vec_box: (buf_ptr: number) => number,
    _ffi_fn_empty_struct: () => void,
    _ffi_fn_empty_tuple: () => void,
    _ffi_fn_enum_box_tup: (buf_ptr: number) => number,
    _ffi_fn_enum_opt_tup: (buf_ptr: number) => number,
    _ffi_fn_enum_vec_tup: (buf_ptr: number) => number,
    _ffi_fn_opt_box: (buf_ptr: number, has_x_0: boolean) => number,
    _ffi_fn_opt_box_opt: (buf_ptr: number, has_x_0: boolean) => number,
    _ffi_fn_opt_tup_0: (buf_ptr: number, has_x_0: boolean) => number,
    _ffi_fn_opt_tup_1: (buf_ptr: number, has_x_0: boolean) => number,
    _ffi_fn_opt_tup_2: (buf_ptr: number, has_x_0: boolean) => number,
    _ffi_fn_rust_mem_leaked: () => number,
    _ffi_fn_tup_box: (buf_ptr: number) => number,
    _ffi_fn_vec_box: (buf_ptr: number, x_0_len: number) => number,
    _ffi_fn_vec_box_vec: (buf_ptr: number, x_0_len: number) => number,
    _ffi_fn_vec_tup_0: (buf_ptr: number, x_0_len: number) => number,
    _ffi_fn_vec_tup_1: (buf_ptr: number, x_0_len: number) => number,
    _ffi_fn_vec_tup_2: (buf_ptr: number, x_0_len: number) => number,
    _ffi_alloc: (len: number) => number,
};

const _ffi_imports = {};
