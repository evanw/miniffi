// This file was generated by miniffi v0.1.0. Do not edit.

#[allow(non_snake_case)]
fn _ffi_box__from_js(_: &mut *const u8) -> Box<()> {
    Box::new(())
}

#[allow(non_snake_case)]
fn _ffi_box__to_js(val: (), _: &mut Vec<u8>) {
    _ = val;
}

fn _ffi_box_bool_from_js(end: &mut *const u8) -> Box<bool> {
    Box::new(_ffi_read::<bool>(end))
}

fn _ffi_box_bool_to_js(val: bool, buf: &mut Vec<u8>) {
    _ffi_write(val, buf);
}

fn _ffi_box_i32_from_js(end: &mut *const u8) -> Box<(i32,)> {
    Box::new((_ffi_read::<i32>(end),))
}

fn _ffi_box_i32_from_js2(end: &mut *const u8) -> Box<i32> {
    Box::new(_ffi_read::<i32>(end))
}

fn _ffi_box_i32_i32_from_js(end: &mut *const u8) -> Box<(i32, i32)> {
    Box::new((_ffi_read::<i32>(end), _ffi_read::<i32>(end)))
}

fn _ffi_box_i32_i32_to_js(val: (i32, i32), buf: &mut Vec<u8>) {
    _ffi_write(val.0, buf);
    _ffi_write(val.1, buf);
}

fn _ffi_box_i32_to_js(val: (i32,), buf: &mut Vec<u8>) {
    _ffi_write(val.0, buf);
}

fn _ffi_box_i32_to_js2(val: i32, buf: &mut Vec<u8>) {
    _ffi_write(val, buf);
}

fn _ffi_box_option_box_i32_from_js(end: &mut *const u8) -> Box<Option<Box<i32>>> {
    Box::new(_ffi_read::<bool>(end).then(|| _ffi_box_i32_from_js2(end)))
}

fn _ffi_box_option_box_i32_to_js(val: Option<Box<i32>>, buf: &mut Vec<u8>) {
    _ffi_write(val.is_some(), buf);
    if let Some(val_val) = val {
        _ffi_box_i32_to_js2(*val_val, buf);
    }
}

fn _ffi_box_option_i32_from_js(end: &mut *const u8) -> Box<Option<i32>> {
    Box::new(_ffi_read::<bool>(end).then(|| _ffi_read::<i32>(end)))
}

fn _ffi_box_option_i32_to_js(val: Option<i32>, buf: &mut Vec<u8>) {
    _ffi_write(val.is_some(), buf);
    if let Some(val_val) = val {
        _ffi_write(val_val, buf);
    }
}

fn _ffi_box_vec_box_i32_from_js(end: &mut *const u8) -> Box<Vec<Box<i32>>> {
    Box::new(_ffi_vec_box_i32_from_js(_ffi_read::<usize>(end), end))
}

fn _ffi_box_vec_box_i32_to_js(val: Vec<Box<i32>>, buf: &mut Vec<u8>) {
    _ffi_write(val.len(), buf);
    _ffi_vec_box_i32_to_js(val, buf);
}

fn _ffi_box_vec_i32_from_js(end: &mut *const u8) -> Box<Vec<i32>> {
    Box::new(_ffi_vec_i32_from_js2(_ffi_read::<usize>(end), end))
}

fn _ffi_box_vec_i32_to_js(val: Vec<i32>, buf: &mut Vec<u8>) {
    _ffi_write(val.len(), buf);
    _ffi_vec_i32_to_js2(val, buf);
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}

#[allow(non_snake_case)]
fn _ffi_enum_EnumBoxTup_from_js(end: &mut *const u8) -> EnumBoxTup {
    match _ffi_read::<i32>(end) {
        0 => EnumBoxTup::Foo(_ffi_box_i32_i32_from_js(end)),
        1 => EnumBoxTup::Bar,
        2 => EnumBoxTup::Baz { x: _ffi_read::<i32>(end), y: _ffi_read::<i32>(end) },
        _ => panic!(),
    }
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = &raw const val as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}

#[allow(non_snake_case)]
fn _ffi_enum_EnumBoxTup_to_js(val: EnumBoxTup, buf: &mut Vec<u8>) {
    match val {
        EnumBoxTup::Foo(x) => {
            _ffi_write(0 as i32, buf);
            _ffi_box_i32_i32_to_js(*x, buf);
        }
        EnumBoxTup::Bar => _ffi_write(1 as i32, buf),
        EnumBoxTup::Baz { x, y } => {
            _ffi_write(2 as i32, buf);
            _ffi_write(x, buf);
            _ffi_write(y, buf);
        }
    }
}

#[allow(non_snake_case)]
fn _ffi_enum_EnumOptTup_from_js(end: &mut *const u8) -> EnumOptTup {
    match _ffi_read::<i32>(end) {
        0 => EnumOptTup::Foo(_ffi_read::<bool>(end).then(|| (_ffi_read::<i32>(end), _ffi_read::<i32>(end)))),
        1 => EnumOptTup::Bar,
        2 => EnumOptTup::Baz { x: _ffi_read::<i32>(end), y: _ffi_read::<i32>(end) },
        _ => panic!(),
    }
}

#[allow(non_snake_case)]
fn _ffi_enum_EnumOptTup_to_js(val: EnumOptTup, buf: &mut Vec<u8>) {
    match val {
        EnumOptTup::Foo(x) => {
            _ffi_write(0 as i32, buf);
            _ffi_write(x.is_some(), buf);
            if let Some(x_val) = x {
                _ffi_write(x_val.0, buf);
                _ffi_write(x_val.1, buf);
            }
        }
        EnumOptTup::Bar => _ffi_write(1 as i32, buf),
        EnumOptTup::Baz { x, y } => {
            _ffi_write(2 as i32, buf);
            _ffi_write(x, buf);
            _ffi_write(y, buf);
        }
    }
}

#[allow(non_snake_case)]
fn _ffi_enum_EnumVecTup_from_js(end: &mut *const u8) -> EnumVecTup {
    match _ffi_read::<i32>(end) {
        0 => EnumVecTup::Foo(_ffi_vec_i32_i32_from_js(_ffi_read::<usize>(end), end)),
        1 => EnumVecTup::Bar,
        2 => EnumVecTup::Baz { x: _ffi_read::<i32>(end), y: _ffi_read::<i32>(end) },
        _ => panic!(),
    }
}

#[allow(non_snake_case)]
fn _ffi_enum_EnumVecTup_to_js(val: EnumVecTup, buf: &mut Vec<u8>) {
    match val {
        EnumVecTup::Foo(x) => {
            _ffi_write(0 as i32, buf);
            _ffi_write(x.len(), buf);
            _ffi_vec_i32_i32_to_js(x, buf);
        }
        EnumVecTup::Bar => _ffi_write(1 as i32, buf),
        EnumVecTup::Baz { x, y } => {
            _ffi_write(2 as i32, buf);
            _ffi_write(x, buf);
            _ffi_write(y, buf);
        }
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_opt(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_opt(BoxOpt(_ffi_box_option_i32_from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_option_i32_to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_opt_box(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_opt_box(BoxOptBox(_ffi_box_option_box_i32_from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_option_box_i32_to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_tup_0(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_tup_0(BoxTup0(_ffi_box__from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box__to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_tup_1(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_tup_1(BoxTup1(_ffi_box_i32_from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_i32_to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_tup_2(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_tup_2(BoxTup2(_ffi_box_i32_i32_from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_i32_i32_to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_vec(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_vec(BoxVec(_ffi_box_vec_i32_from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_vec_i32_to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_box_vec_box(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = box_vec_box(BoxVecBox(_ffi_box_vec_box_i32_from_js(&mut buf_end)));
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_vec_box_i32_to_js(*ret.0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_empty_struct() {
    _ = empty_struct(EmptyStruct);
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_empty_tuple() {
    _ = empty_tuple(());
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_enum_box_tup(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let mut buf2 = Vec::<u8>::new();
    _ffi_enum_EnumBoxTup_to_js(enum_box_tup(_ffi_enum_EnumBoxTup_from_js(&mut buf_end)), &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_enum_opt_tup(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let mut buf2 = Vec::<u8>::new();
    _ffi_enum_EnumOptTup_to_js(enum_opt_tup(_ffi_enum_EnumOptTup_from_js(&mut buf_end)), &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_enum_vec_tup(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let mut buf2 = Vec::<u8>::new();
    _ffi_enum_EnumVecTup_to_js(enum_vec_tup(_ffi_enum_EnumVecTup_from_js(&mut buf_end)), &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_box(buf_ptr: *const u8, has_x_0: bool) -> *const _ffi_ret_ptr_usize_bool {
    let mut buf_end = buf_ptr;
    let ret = opt_box(OptBox(has_x_0.then(|| _ffi_box_i32_from_js2(&mut buf_end))));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let has_ret_0 = ret_0.is_some();
    if let Some(ret_0_val) = ret_0 {
        _ffi_box_i32_to_js2(*ret_0_val, &mut buf2);
    }
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr2, buf_cap, has_ret_0) };
    &raw const _FFI_RET_PTR_USIZE_BOOL
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_box_opt(buf_ptr: *const u8, has_x_0: bool) -> *const _ffi_ret_ptr_usize_bool {
    let mut buf_end = buf_ptr;
    let ret = opt_box_opt(OptBoxOpt(has_x_0.then(|| _ffi_box_option_i32_from_js(&mut buf_end))));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let has_ret_0 = ret_0.is_some();
    if let Some(ret_0_val) = ret_0 {
        _ffi_box_option_i32_to_js(*ret_0_val, &mut buf2);
    }
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr2, buf_cap, has_ret_0) };
    &raw const _FFI_RET_PTR_USIZE_BOOL
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_tup_0(buf_ptr: *const u8, has_x_0: bool) -> *const _ffi_ret_ptr_usize_bool {
    let buf_end = buf_ptr;
    let ret = opt_tup_0(OptTup0(has_x_0.then(|| ())));
    let ret_0 = ret.0;
    let buf2 = Vec::<u8>::new();
    let has_ret_0 = ret_0.is_some();
    if let Some(ret_0_val) = ret_0 {
        _ = ret_0_val;
    }
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr2, buf_cap, has_ret_0) };
    &raw const _FFI_RET_PTR_USIZE_BOOL
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_tup_1(buf_ptr: *const u8, has_x_0: bool) -> *const _ffi_ret_ptr_usize_bool {
    let mut buf_end = buf_ptr;
    let ret = opt_tup_1(OptTup1(has_x_0.then(|| (_ffi_read::<i32>(&mut buf_end),))));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let has_ret_0 = ret_0.is_some();
    if let Some(ret_0_val) = ret_0 {
        _ffi_write(ret_0_val.0, &mut buf2);
    }
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr2, buf_cap, has_ret_0) };
    &raw const _FFI_RET_PTR_USIZE_BOOL
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_tup_2(buf_ptr: *const u8, has_x_0: bool) -> *const _ffi_ret_ptr_usize_bool {
    let mut buf_end = buf_ptr;
    let ret = opt_tup_2(OptTup2(has_x_0.then(|| (_ffi_read::<i32>(&mut buf_end), _ffi_read::<i32>(&mut buf_end)))));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let has_ret_0 = ret_0.is_some();
    if let Some(ret_0_val) = ret_0 {
        _ffi_write(ret_0_val.0, &mut buf2);
        _ffi_write(ret_0_val.1, &mut buf2);
    }
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr2, buf_cap, has_ret_0) };
    &raw const _FFI_RET_PTR_USIZE_BOOL
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_tup_box(buf_ptr: *const u8) -> *const _ffi_ret_ptr_usize {
    let mut buf_end = buf_ptr;
    let ret = tup_box(TupBox((_ffi_box_i32_from_js2(&mut buf_end), _ffi_box_bool_from_js(&mut buf_end))));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    _ffi_box_i32_to_js2(*ret_0.0, &mut buf2);
    _ffi_box_bool_to_js(*ret_0.1, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_USIZE = _ffi_ret_ptr_usize(buf_ptr2, buf_cap) };
    &raw const _FFI_RET_PTR_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_vec_box(buf_ptr: *const u8, x_0_len: usize) -> *const _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let ret = vec_box(VecBox(_ffi_vec_box_i32_from_js(x_0_len, &mut buf_end)));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let ret_0_len = ret_0.len();
    _ffi_vec_box_i32_to_js(ret_0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_2_USIZE = _ffi_ret_ptr_2_usize(buf_ptr2, buf_cap, ret_0_len) };
    &raw const _FFI_RET_PTR_2_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_vec_box_vec(buf_ptr: *const u8, x_0_len: usize) -> *const _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let ret = vec_box_vec(VecBoxVec(_ffi_vec_box_vec_i32_from_js(x_0_len, &mut buf_end)));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let ret_0_len = ret_0.len();
    _ffi_vec_box_vec_i32_to_js(ret_0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_2_USIZE = _ffi_ret_ptr_2_usize(buf_ptr2, buf_cap, ret_0_len) };
    &raw const _FFI_RET_PTR_2_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_vec_tup_0(buf_ptr: *const u8, x_0_len: usize) -> *const _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let ret = vec_tup_0(VecTup0(_ffi_vec__from_js(x_0_len, &mut buf_end)));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let ret_0_len = ret_0.len();
    _ffi_vec__to_js(ret_0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_2_USIZE = _ffi_ret_ptr_2_usize(buf_ptr2, buf_cap, ret_0_len) };
    &raw const _FFI_RET_PTR_2_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_vec_tup_1(buf_ptr: *const u8, x_0_len: usize) -> *const _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let ret = vec_tup_1(VecTup1(_ffi_vec_i32_from_js(x_0_len, &mut buf_end)));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let ret_0_len = ret_0.len();
    _ffi_vec_i32_to_js(ret_0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_2_USIZE = _ffi_ret_ptr_2_usize(buf_ptr2, buf_cap, ret_0_len) };
    &raw const _FFI_RET_PTR_2_USIZE
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_vec_tup_2(buf_ptr: *const u8, x_0_len: usize) -> *const _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let ret = vec_tup_2(VecTup2(_ffi_vec_i32_i32_from_js(x_0_len, &mut buf_end)));
    let ret_0 = ret.0;
    let mut buf2 = Vec::<u8>::new();
    let ret_0_len = ret_0.len();
    _ffi_vec_i32_i32_to_js(ret_0, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    unsafe { _FFI_RET_PTR_2_USIZE = _ffi_ret_ptr_2_usize(buf_ptr2, buf_cap, ret_0_len) };
    &raw const _FFI_RET_PTR_2_USIZE
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);
static mut _FFI_RET_PTR_2_USIZE: _ffi_ret_ptr_2_usize = _ffi_ret_ptr_2_usize(std::ptr::null(), 0, 0);

#[repr(C)]
struct _ffi_ret_ptr_usize(*const u8, usize);
static mut _FFI_RET_PTR_USIZE: _ffi_ret_ptr_usize = _ffi_ret_ptr_usize(std::ptr::null(), 0);

#[repr(C)]
struct _ffi_ret_ptr_usize_bool(*const u8, usize, bool);
static mut _FFI_RET_PTR_USIZE_BOOL: _ffi_ret_ptr_usize_bool = _ffi_ret_ptr_usize_bool(std::ptr::null(), 0, false);

#[allow(non_snake_case)]
fn _ffi_vec__from_js(len: usize, _: &mut *const u8) -> Vec<()> {
    let mut items = Vec::<()>::with_capacity(len);
    for _ in 0..len {
        items.push(());
    }
    items
}

#[allow(non_snake_case)]
fn _ffi_vec__to_js(items: Vec<()>, _: &mut Vec<u8>) {
    for item in items {
        _ = item;
    }
}

fn _ffi_vec_box_i32_from_js(len: usize, end: &mut *const u8) -> Vec<Box<i32>> {
    let mut items = Vec::<Box<i32>>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_box_i32_from_js2(end));
    }
    items
}

fn _ffi_vec_box_i32_to_js(items: Vec<Box<i32>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_box_i32_to_js2(*item, buf);
    }
}

fn _ffi_vec_box_vec_i32_from_js(len: usize, end: &mut *const u8) -> Vec<Box<Vec<i32>>> {
    let mut items = Vec::<Box<Vec<i32>>>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_box_vec_i32_from_js(end));
    }
    items
}

fn _ffi_vec_box_vec_i32_to_js(items: Vec<Box<Vec<i32>>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_box_vec_i32_to_js(*item, buf);
    }
}

fn _ffi_vec_i32_from_js(len: usize, end: &mut *const u8) -> Vec<(i32,)> {
    let mut items = Vec::<(i32,)>::with_capacity(len);
    for _ in 0..len {
        items.push((_ffi_read::<i32>(end),));
    }
    items
}

fn _ffi_vec_i32_from_js2(len: usize, end: &mut *const u8) -> Vec<i32> {
    let mut items = Vec::<i32>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<i32>(end));
    }
    items
}

fn _ffi_vec_i32_i32_from_js(len: usize, end: &mut *const u8) -> Vec<(i32, i32)> {
    let mut items = Vec::<(i32, i32)>::with_capacity(len);
    for _ in 0..len {
        items.push((_ffi_read::<i32>(end), _ffi_read::<i32>(end)));
    }
    items
}

fn _ffi_vec_i32_i32_to_js(items: Vec<(i32, i32)>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.0, buf);
        _ffi_write(item.1, buf);
    }
}

fn _ffi_vec_i32_to_js(items: Vec<(i32,)>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.0, buf);
    }
}

fn _ffi_vec_i32_to_js2(items: Vec<i32>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item, buf);
    }
}
