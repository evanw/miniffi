// This file was generated by miniffi v0.1.0. Do not edit.

export async function instantiate(bytes, imports) {
    let env = Object.assign({}, imports, _ffi_imports);
    let promise = WebAssembly.instantiate(bytes, { env });
    _ffi_exports = (await promise).instance.exports;
    return { memory: _ffi_exports.memory };
}

export async function instantiateStreaming(source, imports) {
    let env = Object.assign({}, imports, _ffi_imports);
    let promise = WebAssembly.instantiateStreaming(source, { env });
    _ffi_exports = (await promise).instance.exports;
    return { memory: _ffi_exports.memory };
}

export function rust_mem_leaked() {
    return _ffi_exports._ffi_fn_rust_mem_leaked();
}

export function empty_tuple(x) {
    _ffi_exports._ffi_fn_empty_tuple();
    return undefined;
}

export function empty_struct(x) {
    _ffi_exports._ffi_fn_empty_struct();
    return {};
}

export function box_tup_0(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box__to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_tup_0(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box__from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_tup_1(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_tup_1(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_tup_2(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_i32_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_tup_2(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box_i32_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_tup_0(x) {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec__to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_tup_0(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_vec__from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_tup_1(x) {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_tup_1(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_vec_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_tup_2(x) {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_i32_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_tup_2(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_vec_i32_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_tup_0(x) {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_tup_0(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: has_ret_0 ? undefined : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_tup_1(x) {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_write_i32(buf, x_0_val[0]);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_tup_1(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: has_ret_0 ? [_ffi_read_i32(buf2)] : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_tup_2(x) {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_write_i32(buf, x_0_val[0]);
        _ffi_write_i32(buf, x_0_val[1]);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_tup_2(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: has_ret_0 ? [_ffi_read_i32(buf2), _ffi_read_i32(buf2)] : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function enum_box_tup(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_enum_EnumBoxTup_to_rust(x, buf);
    let multi_ret = _ffi_exports._ffi_fn_enum_box_tup(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = _ffi_enum_EnumBoxTup_from_rust(buf2);
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function enum_vec_tup(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_enum_EnumVecTup_to_rust(x, buf);
    let multi_ret = _ffi_exports._ffi_fn_enum_vec_tup(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = _ffi_enum_EnumVecTup_from_rust(buf2);
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function enum_opt_tup(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_enum_EnumOptTup_to_rust(x, buf);
    let multi_ret = _ffi_exports._ffi_fn_enum_opt_tup(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = _ffi_enum_EnumOptTup_from_rust(buf2);
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function tup_box(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_i32_to_rust2(x[0][0], buf);
    _ffi_box_bool_to_rust(x[0][1], buf);
    let multi_ret = _ffi_exports._ffi_fn_tup_box(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: [_ffi_box_i32_from_rust2(buf2), _ffi_box_bool_from_rust(buf2)] };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_box(x) {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_box(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_vec_box_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_vec(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_vec_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_vec(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box_vec_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_box(x) {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_box_i32_to_rust2(x_0_val, buf);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_box(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: has_ret_0 ? _ffi_box_i32_from_rust2(buf2) : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_opt(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_option_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_opt(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box_option_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function vec_box_vec(x) {
    let buf = _ffi_new_WriteBuf();
    let x_0_len = x[0].length;
    _ffi_vec_box_vec_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_vec_box_vec(_ffi_buf_to_rust(buf), x_0_len);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let ret_0_len = _ffi_dv.getUint32(multi_ret + 8, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_vec_box_vec_i32_from_rust(ret_0_len, buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_vec_box(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_vec_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_vec_box(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box_vec_box_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function opt_box_opt(x) {
    let buf = _ffi_new_WriteBuf();
    let has_x_0 = x[0] !== null;
    if (x[0] !== null) {
        let x_0_val = x[0];
        _ffi_box_option_i32_to_rust(x_0_val, buf);
    }
    let multi_ret = _ffi_exports._ffi_fn_opt_box_opt(_ffi_buf_to_rust(buf), has_x_0);
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let has_ret_0 = _ffi_dv.getUint8(multi_ret + 8);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: has_ret_0 ? _ffi_box_option_i32_from_rust(buf2) : null };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

export function box_opt_box(x) {
    let buf = _ffi_new_WriteBuf();
    _ffi_box_option_box_i32_to_rust(x[0], buf);
    let multi_ret = _ffi_exports._ffi_fn_box_opt_box(_ffi_buf_to_rust(buf));
    let buf_ptr2 = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 4, true);
    let buf2 = _ffi_new_ReadBuf(buf_ptr2);
    let ret = { 0: _ffi_box_option_box_i32_from_rust(buf2) };
    _ffi_exports._ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

let _ffi_dv;
let _ffi_new_ReadBuf = (off) => ({ dv: _ffi_update_dv(), off });
let _ffi_new_WriteBuf = () => ({ u8: new Uint8Array(16), dv: null, off: 0 });
let _ffi_u8;
let _ffi_enum_EnumBoxTup__Bar = { $: "Bar" };
let _ffi_enum_EnumOptTup__Bar = { $: "Bar" };
let _ffi_enum_EnumVecTup__Bar = { $: "Bar" };

function _ffi_update_dv() {
    let buffer = _ffi_exports.memory.buffer;
    if (!_ffi_dv || _ffi_dv.buffer !== buffer) _ffi_dv = new DataView(buffer);
    return _ffi_dv;
}

function _ffi_box__from_rust(buf) {
    return undefined;
}

function _ffi_box__to_rust(val, buf) {
}

function _ffi_box_bool_from_rust(buf) {
    return !!_ffi_read_u8(buf);
}

function _ffi_box_bool_to_rust(val, buf) {
    _ffi_write_i8(buf, +val);
}

function _ffi_box_i32_from_rust(buf) {
    return [_ffi_read_i32(buf)];
}

function _ffi_box_i32_from_rust2(buf) {
    return _ffi_read_i32(buf);
}

function _ffi_box_i32_i32_from_rust(buf) {
    return [_ffi_read_i32(buf), _ffi_read_i32(buf)];
}

function _ffi_box_i32_i32_to_rust(val, buf) {
    _ffi_write_i32(buf, val[0]);
    _ffi_write_i32(buf, val[1]);
}

function _ffi_box_i32_to_rust(val, buf) {
    _ffi_write_i32(buf, val[0]);
}

function _ffi_box_i32_to_rust2(val, buf) {
    _ffi_write_i32(buf, val);
}

function _ffi_box_option_box_i32_from_rust(buf) {
    return _ffi_read_u8(buf) ? _ffi_box_i32_from_rust2(buf) : null;
}

function _ffi_box_option_box_i32_to_rust(val, buf) {
    _ffi_write_i8(buf, +(val !== null));
    if (val !== null) {
        let val_val = val;
        _ffi_box_i32_to_rust2(val_val, buf);
    }
}

function _ffi_box_option_i32_from_rust(buf) {
    return _ffi_read_u8(buf) ? _ffi_read_i32(buf) : null;
}

function _ffi_box_option_i32_to_rust(val, buf) {
    _ffi_write_i8(buf, +(val !== null));
    if (val !== null) {
        _ffi_write_i32(buf, val);
    }
}

function _ffi_box_vec_box_i32_from_rust(buf) {
    return _ffi_vec_box_i32_from_rust(_ffi_read_u32(buf), buf);
}

function _ffi_box_vec_box_i32_to_rust(val, buf) {
    _ffi_write_i32(buf, val.length);
    _ffi_vec_box_i32_to_rust(val, buf);
}

function _ffi_box_vec_i32_from_rust(buf) {
    return _ffi_vec_i32_from_rust2(_ffi_read_u32(buf), buf);
}

function _ffi_box_vec_i32_to_rust(val, buf) {
    _ffi_write_i32(buf, val.length);
    _ffi_vec_i32_to_rust2(val, buf);
}

function _ffi_update_u8() {
    let buffer = _ffi_exports.memory.buffer;
    if (!_ffi_u8 || _ffi_u8.buffer !== buffer) _ffi_u8 = new Uint8Array(buffer);
    return _ffi_u8;
}

function _ffi_buf_to_rust({ u8, off }) {
    let ptr = _ffi_exports._ffi_alloc(off);
    _ffi_update_u8().set(u8.length > off ? u8.subarray(0, off) : u8, ptr);
    return ptr;
}

function _ffi_enum_EnumBoxTup_from_rust(buf) {
    switch (_ffi_read_i32(buf)) {
        case 0: return { $: "Foo", 0: _ffi_box_i32_i32_from_rust(buf) };
        case 1: return _ffi_enum_EnumBoxTup__Bar;
        case 2: return { $: "Baz", x: _ffi_read_i32(buf), y: _ffi_read_i32(buf) };
        default: throw Error();
    }
}

function _ffi_enum_EnumBoxTup_to_rust(val, buf) {
    switch (val.$) {
        case "Foo":
            _ffi_write_i32(buf, 0);
            _ffi_box_i32_i32_to_rust(val[0], buf);
            break;
        case "Bar":
            _ffi_write_i32(buf, 1);
            break;
        case "Baz":
            _ffi_write_i32(buf, 2);
            _ffi_write_i32(buf, val.x);
            _ffi_write_i32(buf, val.y);
            break;
        default:
            throw TypeError("Invalid value for enum \"EnumBoxTup\"");
    }
}

function _ffi_enum_EnumOptTup_from_rust(buf) {
    switch (_ffi_read_i32(buf)) {
        case 0: return { $: "Foo", 0: _ffi_read_u8(buf) ? [_ffi_read_i32(buf), _ffi_read_i32(buf)] : null };
        case 1: return _ffi_enum_EnumOptTup__Bar;
        case 2: return { $: "Baz", x: _ffi_read_i32(buf), y: _ffi_read_i32(buf) };
        default: throw Error();
    }
}

function _ffi_enum_EnumOptTup_to_rust(val, buf) {
    switch (val.$) {
        case "Foo":
            _ffi_write_i32(buf, 0);
            _ffi_write_i8(buf, +(val[0] !== null));
            if (val[0] !== null) {
                let x_val = val[0];
                _ffi_write_i32(buf, x_val[0]);
                _ffi_write_i32(buf, x_val[1]);
            }
            break;
        case "Bar":
            _ffi_write_i32(buf, 1);
            break;
        case "Baz":
            _ffi_write_i32(buf, 2);
            _ffi_write_i32(buf, val.x);
            _ffi_write_i32(buf, val.y);
            break;
        default:
            throw TypeError("Invalid value for enum \"EnumOptTup\"");
    }
}

function _ffi_enum_EnumVecTup_from_rust(buf) {
    switch (_ffi_read_i32(buf)) {
        case 0: return { $: "Foo", 0: _ffi_vec_i32_i32_from_rust(_ffi_read_u32(buf), buf) };
        case 1: return _ffi_enum_EnumVecTup__Bar;
        case 2: return { $: "Baz", x: _ffi_read_i32(buf), y: _ffi_read_i32(buf) };
        default: throw Error();
    }
}

function _ffi_enum_EnumVecTup_to_rust(val, buf) {
    switch (val.$) {
        case "Foo":
            _ffi_write_i32(buf, 0);
            _ffi_write_i32(buf, val[0].length);
            _ffi_vec_i32_i32_to_rust(val[0], buf);
            break;
        case "Bar":
            _ffi_write_i32(buf, 1);
            break;
        case "Baz":
            _ffi_write_i32(buf, 2);
            _ffi_write_i32(buf, val.x);
            _ffi_write_i32(buf, val.y);
            break;
        default:
            throw TypeError("Invalid value for enum \"EnumVecTup\"");
    }
}

function _ffi_read_i32(buf) {
    let val = buf.dv.getInt32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_u32(buf) {
    let val = buf.dv.getUint32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_u8(buf) {
    return buf.dv.getUint8(buf.off++);
}

function _ffi_vec__from_rust(len, buf) {
    let items = [];
    while (items.length < len) {
        items.push(undefined);
    }
    return items;
}

function _ffi_vec__to_rust(items, buf) {
}

function _ffi_vec_box_i32_from_rust(len, buf) {
    let items = [];
    while (items.length < len) {
        items.push(_ffi_box_i32_from_rust2(buf));
    }
    return items;
}

function _ffi_vec_box_i32_to_rust(items, buf) {
    for (const item of items) {
        _ffi_box_i32_to_rust2(item, buf);
    }
}

function _ffi_vec_box_vec_i32_from_rust(len, buf) {
    let items = [];
    while (items.length < len) {
        items.push(_ffi_box_vec_i32_from_rust(buf));
    }
    return items;
}

function _ffi_vec_box_vec_i32_to_rust(items, buf) {
    for (const item of items) {
        _ffi_box_vec_i32_to_rust(item, buf);
    }
}

function _ffi_vec_i32_from_rust(len, buf) {
    let items = [];
    while (items.length < len) {
        items.push([_ffi_read_i32(buf)]);
    }
    return items;
}

function _ffi_vec_i32_from_rust2(len, buf) {
    let items = [];
    while (items.length < len) {
        items.push(_ffi_read_i32(buf));
    }
    return items;
}

function _ffi_vec_i32_i32_from_rust(len, buf) {
    let items = [];
    while (items.length < len) {
        items.push([_ffi_read_i32(buf), _ffi_read_i32(buf)]);
    }
    return items;
}

function _ffi_vec_i32_i32_to_rust(items, buf) {
    for (const item of items) {
        _ffi_write_i32(buf, item[0]);
        _ffi_write_i32(buf, item[1]);
    }
}

function _ffi_vec_i32_to_rust(items, buf) {
    for (const item of items) {
        _ffi_write_i32(buf, item[0]);
    }
}

function _ffi_vec_i32_to_rust2(items, buf) {
    for (const item of items) {
        _ffi_write_i32(buf, item);
    }
}

function _ffi_grow(buf, n) {
    let off = buf.off;
    let u8 = buf.u8;
    if (off + n > u8.length) {
        (buf.u8 = new Uint8Array((off + n) << 1)).set(u8);
        buf.dv = null;
    }
    buf.off += n;
    if (!buf.dv) buf.dv = new DataView(buf.u8.buffer);
    return off;
}

function _ffi_write_i32(buf, val) {
    let ptr = _ffi_grow(buf, 4);
    buf.dv.setInt32(ptr, val, true);
}

function _ffi_write_i8(buf, val) {
    let ptr = _ffi_grow(buf, 1);
    buf.dv.setInt8(ptr, val);
}

let _ffi_exports;

const _ffi_imports = {};
