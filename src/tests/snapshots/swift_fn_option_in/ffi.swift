// This file was generated by miniffi v0.1.0. Do not edit.

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func add_option(_ x: Int32?, _ y: Int32?) -> Int32 {
    var buf = ContiguousArray<UInt8>()
    let has_x = x != nil
    if let x_val = x {
        _ffi_write(x_val, &buf)
    }
    let has_y = y != nil
    if let y_val = y {
        _ffi_write(y_val, &buf)
    }
    return _ffi_fn_add_option(_ffi_vec_to_rust(buf), has_x, has_y)
}

func add_nested(_ x: Int32??, _ y: Int32??) -> Int32 {
    var buf = ContiguousArray<UInt8>()
    let has_x = x != nil
    if let x_val = x {
        _ffi_write(x_val != nil, &buf)
        if let x_val_val = x_val {
            _ffi_write(x_val_val, &buf)
        }
    }
    let has_y = y != nil
    if let y_val = y {
        _ffi_write(y_val != nil, &buf)
        if let y_val_val = y_val {
            _ffi_write(y_val_val, &buf)
        }
    }
    return _ffi_fn_add_nested(_ffi_vec_to_rust(buf), has_x, has_y)
}

func add_all(_ x: [Int32?]) -> Int32 {
    var buf = ContiguousArray<UInt8>()
    let x_len = UInt(x.count)
    _ffi_vec_option_i32_to_rust(x, &buf)
    return _ffi_fn_add_all(_ffi_vec_to_rust(buf), x_len)
}

func join_all(_ x: [String?]) -> String {
    var buf = ContiguousArray<UInt8>()
    let x_len = UInt(x.count)
    _ffi_vec_option_string_to_rust(x, &buf)
    let multi_ret = _ffi_fn_join_all(_ffi_vec_to_rust(buf), x_len)
    let ret_ptr = multi_ret._0
    let ret_len = multi_ret._1
    let ret_cap = multi_ret._2
    return _ffi_string_from_rust(ret_ptr, Int(ret_len), ret_cap)
}

private func _ffi_string_from_rust(_ ptr: UnsafeRawPointer?, _ len: Int, _ cap: UInt) -> String {
    let buf = UnsafeBufferPointer(start: ptr!.assumingMemoryBound(to: UInt8.self), count: len)
    let str = String(decoding: buf, as: UTF8.self)
    _ffi_dealloc(ptr, cap)
    return str
}

private func _ffi_string_to_rust(_ str: String) -> (UnsafeRawPointer?, UInt) {
    var str = str
    return str.withUTF8 { str in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(str.count), count: str.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: str.baseAddress, count: str.count))
        return (UnsafeRawPointer(buf.baseAddress), UInt(buf.count))
    }
}

private func _ffi_vec_option_i32_to_rust(_ items: [Int32?], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item != nil, &buf)
        if let item_val = item {
            _ffi_write(item_val, &buf)
        }
    }
}

private func _ffi_vec_option_string_to_rust(_ items: [String?], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item != nil, &buf)
        if let item_val = item {
            let (item_val_ptr, item_val_len) = _ffi_string_to_rust(item_val);
            _ffi_write(item_val_ptr, &buf)
            _ffi_write(item_val_len, &buf)
        }
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
