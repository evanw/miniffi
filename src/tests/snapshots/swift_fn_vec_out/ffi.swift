// This file was generated by miniffi v0.1.0. Do not edit.

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func get_vec(_ n: Int32) -> [Int32] {
    let multi_ret = _ffi_fn_get_vec(n)
    let buf_ptr = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_len = multi_ret._2
    var buf_end = buf_ptr!
    let ret = _ffi_vec_i32_from_rust(Int(ret_len), &buf_end)
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

func check_nested() -> [[Int32]] {
    let multi_ret = _ffi_fn_check_nested()
    let buf_ptr = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_len = multi_ret._2
    var buf_end = buf_ptr!
    let ret = _ffi_vec_vec_i32_from_rust(Int(ret_len), &buf_end)
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

private func _ffi_read<T>(_ ptr: inout UnsafeRawPointer) -> T {
    let val = ptr.loadUnaligned(fromByteOffset: 0, as: T.self)
    ptr = ptr.advanced(by: MemoryLayout<T>.size)
    return val
}

private func _ffi_vec_i32_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Int32] {
    var items: [Int32] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_read(&end) as Int32)
    }
    return items
}

private func _ffi_vec_vec_i32_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [[Int32]] {
    var items: [[Int32]] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_vec_i32_from_rust(Int(_ffi_read(&end) as UInt), &end))
    }
    return items
}
