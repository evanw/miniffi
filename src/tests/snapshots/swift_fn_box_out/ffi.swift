// This file was generated by miniffi v0.1.0. Do not edit.

class Tree : Equatable {
    var value: Int32
    var left: Tree?
    var right: Tree?

    init(value: Int32, left: Tree?, right: Tree?) {
        self.value = value
        self.left = left
        self.right = right
    }

    static func == (a: Tree, b: Tree) -> Bool {
        return a.value == b.value && a.left == b.left && a.right == b.right
    }
}

struct Nested : Equatable {
    var _0: Int32
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func get_tree() -> Tree {
    let multi_ret = _ffi_fn_get_tree()
    let ret_value = multi_ret._0
    let buf_ptr = multi_ret._1
    let buf_cap = multi_ret._2
    let has_ret_left = multi_ret._3
    let has_ret_right = multi_ret._4
    var buf_end = buf_ptr!
    let ret = Tree(
        value: ret_value,
        left: has_ret_left ? _ffi_box_Tree_from_rust(&buf_end) : nil,
        right: has_ret_right ? _ffi_box_Tree_from_rust(&buf_end) : nil
    )
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

func check_nested(_ x: Int32) -> Nested {
    let multi_ret = _ffi_fn_check_nested(x)
    let buf_ptr = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end = buf_ptr!
    let ret = Nested(_0: _ffi_box_box_box_i32_from_rust(&buf_end))
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

private func _ffi_box_Tree_from_rust(_ end: inout UnsafeRawPointer) -> Tree {
    return Tree(
        value: _ffi_read(&end) as Int32,
        left: _ffi_read(&end) as Bool ? _ffi_box_Tree_from_rust(&end) : nil,
        right: _ffi_read(&end) as Bool ? _ffi_box_Tree_from_rust(&end) : nil
    )
}

private func _ffi_box_box_box_i32_from_rust(_ end: inout UnsafeRawPointer) -> Int32 {
    return _ffi_box_box_i32_from_rust(&end)
}

private func _ffi_box_box_i32_from_rust(_ end: inout UnsafeRawPointer) -> Int32 {
    return _ffi_box_i32_from_rust(&end)
}

private func _ffi_box_i32_from_rust(_ end: inout UnsafeRawPointer) -> Int32 {
    return _ffi_read(&end) as Int32
}

private func _ffi_read<T>(_ ptr: inout UnsafeRawPointer) -> T {
    let val = ptr.loadUnaligned(fromByteOffset: 0, as: T.self)
    ptr = ptr.advanced(by: MemoryLayout<T>.size)
    return val
}
