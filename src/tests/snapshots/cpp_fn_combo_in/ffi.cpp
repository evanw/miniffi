// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_ptr_2_usize {
    const char* _0;
    uintptr_t _1;
    uintptr_t _2;
};

extern "C" {

_ffi_ret_ptr_2_usize _ffi_fn_check_combo(int32_t foo_x_0_x, const void* buf_ptr, uintptr_t foo_x_0_y_len, uintptr_t foo_x_1_len, uintptr_t foo_y_len);
void _ffi_dealloc(const void* ptr, uintptr_t capacity);
void* _ffi_alloc(uintptr_t len);
uintptr_t _ffi_fn_rust_mem_leaked();

} // extern "C"

namespace {

std::string _ffi_string_from_rust(const char* ptr, uintptr_t len, uintptr_t cap) {
    std::string str(ptr, len);
    _ffi_dealloc(ptr, cap);
    return str;
}

void _ffi_vec_Bar_to_rust(std::vector<rust::Bar>&& items, std::vector<uint8_t>& buf);

void _ffi_vec_Foo_to_rust(std::vector<rust::Foo>&& items, std::vector<uint8_t>& buf);

template <typename T>
void _ffi_write(T val, std::vector<uint8_t> &buf) {
    buf.insert(buf.end(), (const uint8_t*)&val, (const uint8_t*)&val + sizeof(T));
}

void _ffi_vec__i32_f32_bool_to_rust(std::vector<std::tuple<std::tuple<>, std::tuple<int32_t>, std::tuple<float, bool>>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        (void)std::get<0>(item);
        _ffi_write(std::get<0>(std::get<1>(item)), buf);
        _ffi_write(std::get<0>(std::get<2>(item)), buf);
        _ffi_write(std::get<1>(std::get<2>(item)), buf);
    }
}

void _ffi_vec_Foo_to_rust(std::vector<rust::Foo>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_write(std::get<0>(item.x).x, buf);
        auto item_x_0_y_len = std::get<0>(item.x).y.size();
        _ffi_write(item_x_0_y_len, buf);
        _ffi_vec_Foo_to_rust(std::move(std::get<0>(item.x).y), buf);
        auto item_x_1_len = std::get<1>(item.x).size();
        _ffi_write(item_x_1_len, buf);
        _ffi_vec_Bar_to_rust(std::move(std::get<1>(item.x)), buf);
        auto item_y_len = item.y.size();
        _ffi_write(item_y_len, buf);
        _ffi_vec__i32_f32_bool_to_rust(std::move(item.y), buf);
    }
}

void _ffi_vec_Bar_to_rust(std::vector<rust::Bar>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_write(item.x, buf);
        auto item_y_len = item.y.size();
        _ffi_write(item_y_len, buf);
        _ffi_vec_Foo_to_rust(std::move(item.y), buf);
    }
}

const void* _ffi_vec_to_rust(const std::vector<uint8_t>& vec) {
    return memcpy(_ffi_alloc(vec.size()), vec.data(), vec.size());
}

} // namespace

std::string rust::check_combo(rust::Foo foo) {
    std::vector<uint8_t> buf;
    auto foo_x_0_y_len = std::get<0>(foo.x).y.size();
    _ffi_vec_Foo_to_rust(std::move(std::get<0>(foo.x).y), buf);
    auto foo_x_1_len = std::get<1>(foo.x).size();
    _ffi_vec_Bar_to_rust(std::move(std::get<1>(foo.x)), buf);
    auto foo_y_len = foo.y.size();
    _ffi_vec__i32_f32_bool_to_rust(std::move(foo.y), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_check_combo(std::get<0>(foo.x).x, buf_ptr, foo_x_0_y_len, foo_x_1_len, foo_y_len);
    auto ret_ptr = multi_ret._0;
    auto ret_len = multi_ret._1;
    auto ret_cap = multi_ret._2;
    return _ffi_string_from_rust(ret_ptr, ret_len, ret_cap);
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}
