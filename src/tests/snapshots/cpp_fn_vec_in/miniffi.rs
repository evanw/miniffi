// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_check_nested(buf_ptr: *const u8, values_len: usize) -> _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let (ret_ptr, ret_len, ret_cap) = _ffi_string_to_host(check_nested(_ffi_vec_vec_i32_from_cpp(values_len, &mut buf_end)));
    _ffi_buf_from_host(buf_ptr, buf_end);
    _ffi_ret_ptr_2_usize(ret_ptr, ret_len, ret_cap)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_f32(buf_ptr: *const u8, values_len: usize) -> f32 {
    let mut buf_end = buf_ptr;
    let ret = sum_f32(_ffi_vec_f32_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_f64(buf_ptr: *const u8, values_len: usize) -> f64 {
    let mut buf_end = buf_ptr;
    let ret = sum_f64(_ffi_vec_f64_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_i16(buf_ptr: *const u8, values_len: usize) -> i16 {
    let mut buf_end = buf_ptr;
    let ret = sum_i16(_ffi_vec_i16_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_i32(buf_ptr: *const u8, values_len: usize) -> i32 {
    let mut buf_end = buf_ptr;
    let ret = sum_i32(_ffi_vec_i32_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_i64(buf_ptr: *const u8, values_len: usize) -> i64 {
    let mut buf_end = buf_ptr;
    let ret = sum_i64(_ffi_vec_i64_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_i8(buf_ptr: *const u8, values_len: usize) -> i8 {
    let mut buf_end = buf_ptr;
    let ret = sum_i8(_ffi_vec_i8_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_isize(buf_ptr: *const u8, values_len: usize) -> isize {
    let mut buf_end = buf_ptr;
    let ret = sum_isize(_ffi_vec_isize_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_u16(buf_ptr: *const u8, values_len: usize) -> u16 {
    let mut buf_end = buf_ptr;
    let ret = sum_u16(_ffi_vec_u16_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_u32(buf_ptr: *const u8, values_len: usize) -> u32 {
    let mut buf_end = buf_ptr;
    let ret = sum_u32(_ffi_vec_u32_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_u64(buf_ptr: *const u8, values_len: usize) -> u64 {
    let mut buf_end = buf_ptr;
    let ret = sum_u64(_ffi_vec_u64_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_u8(buf_ptr: *const u8, values_len: usize) -> u8 {
    let mut buf_end = buf_ptr;
    let ret = sum_u8(_ffi_vec_u8_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_usize(buf_ptr: *const u8, values_len: usize) -> usize {
    let mut buf_end = buf_ptr;
    let ret = sum_usize(_ffi_vec_usize_from_cpp(values_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_string_to_host(buf: String) -> (*const u8, usize, usize) {
    let buf = std::mem::ManuallyDrop::new(buf.into_bytes());
    (buf.as_ptr(), buf.len(), buf.capacity())
}

fn _ffi_vec_f32_from_cpp(len: usize, end: &mut *const u8) -> Vec<f32> {
    let mut items = Vec::<f32>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<f32>(end));
    }
    items
}

fn _ffi_vec_f64_from_cpp(len: usize, end: &mut *const u8) -> Vec<f64> {
    let mut items = Vec::<f64>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<f64>(end));
    }
    items
}

fn _ffi_vec_i16_from_cpp(len: usize, end: &mut *const u8) -> Vec<i16> {
    let mut items = Vec::<i16>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<i16>(end));
    }
    items
}

fn _ffi_vec_i32_from_cpp(len: usize, end: &mut *const u8) -> Vec<i32> {
    let mut items = Vec::<i32>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<i32>(end));
    }
    items
}

fn _ffi_vec_i64_from_cpp(len: usize, end: &mut *const u8) -> Vec<i64> {
    let mut items = Vec::<i64>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<i64>(end));
    }
    items
}

fn _ffi_vec_i8_from_cpp(len: usize, end: &mut *const u8) -> Vec<i8> {
    let mut items = Vec::<i8>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<i8>(end));
    }
    items
}

fn _ffi_vec_isize_from_cpp(len: usize, end: &mut *const u8) -> Vec<isize> {
    let mut items = Vec::<isize>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<isize>(end));
    }
    items
}

fn _ffi_vec_u16_from_cpp(len: usize, end: &mut *const u8) -> Vec<u16> {
    let mut items = Vec::<u16>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<u16>(end));
    }
    items
}

fn _ffi_vec_u32_from_cpp(len: usize, end: &mut *const u8) -> Vec<u32> {
    let mut items = Vec::<u32>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<u32>(end));
    }
    items
}

fn _ffi_vec_u64_from_cpp(len: usize, end: &mut *const u8) -> Vec<u64> {
    let mut items = Vec::<u64>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<u64>(end));
    }
    items
}

fn _ffi_vec_u8_from_cpp(len: usize, end: &mut *const u8) -> Vec<u8> {
    let mut items = Vec::<u8>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<u8>(end));
    }
    items
}

fn _ffi_vec_usize_from_cpp(len: usize, end: &mut *const u8) -> Vec<usize> {
    let mut items = Vec::<usize>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<usize>(end));
    }
    items
}

fn _ffi_vec_vec_i32_from_cpp(len: usize, end: &mut *const u8) -> Vec<Vec<i32>> {
    let mut items = Vec::<Vec<i32>>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_vec_i32_from_cpp(_ffi_read::<usize>(end), end));
    }
    items
}
