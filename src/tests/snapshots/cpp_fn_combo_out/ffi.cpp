// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_i32_ptr_4_usize {
    int32_t _0;
    const void* _1;
    uintptr_t _2;
    uintptr_t _3;
    uintptr_t _4;
    uintptr_t _5;
};

extern "C" {

void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_i32_ptr_4_usize _ffi_fn_check_combo1();
_ffi_ret_i32_ptr_4_usize _ffi_fn_check_combo2();
uintptr_t _ffi_fn_rust_mem_leaked();

} // extern "C"

namespace {

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

std::vector<rust::Bar> _ffi_vec_Bar_from_rust(uintptr_t len, const uint8_t*& end);

std::vector<rust::Foo> _ffi_vec_Foo_from_rust(uintptr_t len, const uint8_t*& end);

std::vector<std::tuple<std::tuple<>, std::tuple<int32_t>, std::tuple<float, bool>>> _ffi_vec__i32_f32_bool_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::tuple<std::tuple<>, std::tuple<int32_t>, std::tuple<float, bool>>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_0 = std::tuple<>();
        auto item_1_0 = _ffi_read<int32_t>(end);
        auto item_1 = item_1_0;
        auto item_2_0 = _ffi_read<float>(end);
        auto item_2_1 = _ffi_read<bool>(end);
        auto item_2 = std::make_tuple(item_2_0, item_2_1);
        auto item = std::make_tuple(std::move(item_0), std::move(item_1), std::move(item_2));
        items.emplace_back(std::move(item));
    }
    return items;
}

std::vector<rust::Foo> _ffi_vec_Foo_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<rust::Foo> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_x_0_x = _ffi_read<int32_t>(end);
        auto item_x_0_y_len = _ffi_read<uintptr_t>(end);
        auto item_x_0_y = _ffi_vec_Foo_from_rust(item_x_0_y_len, end);
        auto item_x_0 = rust::Bar{item_x_0_x, std::move(item_x_0_y)};
        auto item_x_1_len = _ffi_read<uintptr_t>(end);
        auto item_x_1 = _ffi_vec_Bar_from_rust(item_x_1_len, end);
        auto item_x = std::make_tuple(std::move(item_x_0), std::move(item_x_1));
        auto item_y_len = _ffi_read<uintptr_t>(end);
        auto item_y = _ffi_vec__i32_f32_bool_from_rust(item_y_len, end);
        auto item = rust::Foo{std::move(item_x), std::move(item_y)};
        items.emplace_back(std::move(item));
    }
    return items;
}

std::vector<rust::Bar> _ffi_vec_Bar_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<rust::Bar> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_x = _ffi_read<int32_t>(end);
        auto item_y_len = _ffi_read<uintptr_t>(end);
        auto item_y = _ffi_vec_Foo_from_rust(item_y_len, end);
        auto item = rust::Bar{item_x, std::move(item_y)};
        items.emplace_back(std::move(item));
    }
    return items;
}

} // namespace

bool rust::Bar::operator == (const rust::Bar& b) const {
    return x == b.x && y == b.y;
}

bool rust::Foo::operator == (const rust::Foo& f) const {
    return x == f.x && y == f.y;
}

rust::Foo rust::check_combo1() {
    auto multi_ret = _ffi_fn_check_combo1();
    auto ret_x_0_x = multi_ret._0;
    auto buf_ptr = multi_ret._1;
    auto buf_cap = multi_ret._2;
    auto ret_x_0_y_len = multi_ret._3;
    auto ret_x_1_len = multi_ret._4;
    auto ret_y_len = multi_ret._5;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret_x_0_y = _ffi_vec_Foo_from_rust(ret_x_0_y_len, buf_end);
    auto ret_x_0 = rust::Bar{ret_x_0_x, std::move(ret_x_0_y)};
    auto ret_x_1 = _ffi_vec_Bar_from_rust(ret_x_1_len, buf_end);
    auto ret_x = std::make_tuple(std::move(ret_x_0), std::move(ret_x_1));
    auto ret_y = _ffi_vec__i32_f32_bool_from_rust(ret_y_len, buf_end);
    auto ret = rust::Foo{std::move(ret_x), std::move(ret_y)};
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

rust::Foo rust::check_combo2() {
    auto multi_ret = _ffi_fn_check_combo2();
    auto ret_x_0_x = multi_ret._0;
    auto buf_ptr = multi_ret._1;
    auto buf_cap = multi_ret._2;
    auto ret_x_0_y_len = multi_ret._3;
    auto ret_x_1_len = multi_ret._4;
    auto ret_y_len = multi_ret._5;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret_x_0_y = _ffi_vec_Foo_from_rust(ret_x_0_y_len, buf_end);
    auto ret_x_0 = rust::Bar{ret_x_0_x, std::move(ret_x_0_y)};
    auto ret_x_1 = _ffi_vec_Bar_from_rust(ret_x_1_len, buf_end);
    auto ret_x = std::make_tuple(std::move(ret_x_0), std::move(ret_x_1));
    auto ret_y = _ffi_vec__i32_f32_bool_from_rust(ret_y_len, buf_end);
    auto ret = rust::Foo{std::move(ret_x), std::move(ret_y)};
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}
