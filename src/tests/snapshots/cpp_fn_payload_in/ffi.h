// This file was generated by miniffi v0.1.0. Do not edit.

#pragma once

#include <stdint.h>
#include <vector>
#include <variant>
#include <memory>

namespace rust {

struct Foo;

namespace detail {

struct Foo__Empty {
    bool operator == (const Foo__Empty&) const { return true; }
    bool operator != (const Foo__Empty& f) const { return !(*this == f); }
};

struct Foo__Single {
    int32_t _0 = 0;
    bool operator == (const Foo__Single&) const;
    bool operator != (const Foo__Single& f) const { return !(*this == f); }
};

struct Foo__Point {
    int32_t x = 0;
    int32_t y = 0;
    bool operator == (const Foo__Point&) const;
    bool operator != (const Foo__Point& f) const { return !(*this == f); }
};

struct Foo__Nested {
    std::unique_ptr<Foo> _0;
    bool operator == (const Foo__Nested&) const;
    bool operator != (const Foo__Nested& f) const { return !(*this == f); }
};

} // namespace detail

struct Foo : std::variant<std::monostate, detail::Foo__Empty, detail::Foo__Single, detail::Foo__Point, detail::Foo__Nested> {
    using Empty = detail::Foo__Empty;
    using Single = detail::Foo__Single;
    using Point = detail::Foo__Point;
    using Nested = detail::Foo__Nested;
    using std::variant<std::monostate, Empty, Single, Point, Nested>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

uintptr_t rust_mem_leaked();

bool set_tests(std::vector<Foo> tests);

} // namespace rust
