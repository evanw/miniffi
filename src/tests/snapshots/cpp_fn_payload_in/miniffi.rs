// This file was generated by miniffi v0.1.0. Do not edit.

#[allow(non_snake_case)]
fn _ffi_box_Foo_from_cpp(end: &mut *const u8) -> Box<Foo> {
    Box::new(_ffi_enum_Foo_from_cpp(end))
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}

#[allow(non_snake_case)]
fn _ffi_enum_Foo_from_cpp(end: &mut *const u8) -> Foo {
    match _ffi_read::<i32>(end) {
        0 => Foo::Empty,
        1 => Foo::Single(_ffi_read::<i32>(end)),
        2 => Foo::Point { x: _ffi_read::<i32>(end), y: _ffi_read::<i32>(end) },
        3 => Foo::Nested(_ffi_box_Foo_from_cpp(end)),
        _ => panic!(),
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_set_tests(buf_ptr: *const u8, tests_len: usize) -> bool {
    let mut buf_end = buf_ptr;
    let ret = set_tests(_ffi_vec_Foo_from_cpp(tests_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[allow(non_snake_case)]
fn _ffi_vec_Foo_from_cpp(len: usize, end: &mut *const u8) -> Vec<Foo> {
    let mut items = Vec::<Foo>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_enum_Foo_from_cpp(end));
    }
    items
}
