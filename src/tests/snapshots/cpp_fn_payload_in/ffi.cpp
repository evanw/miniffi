// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"
#include <stdlib.h>

extern "C" {

uintptr_t _ffi_fn_rust_mem_leaked();
bool _ffi_fn_set_tests(const void* buf_ptr, uintptr_t tests_len);
void* _ffi_alloc(uintptr_t len);

} // extern "C"

namespace {

void _ffi_enum_Foo_to_rust(rust::Foo val, std::vector<uint8_t>& buf);

void _ffi_box_Foo_to_rust(rust::Foo val, std::vector<uint8_t>& buf) {
    _ffi_enum_Foo_to_rust(std::move(val), buf);
}

template <typename T>
void _ffi_write(T val, std::vector<uint8_t> &buf) {
    buf.insert(buf.end(), (const uint8_t*)&val, (const uint8_t*)&val + sizeof(T));
}

void _ffi_enum_Foo_to_rust(rust::Foo val, std::vector<uint8_t>& buf) {
    if (val.is<rust::Foo::Empty>()) {
        _ffi_write(int32_t(0), buf);
    } else if (auto it = val.as<rust::Foo::Single>()) {
        _ffi_write(int32_t(1), buf);
        _ffi_write(it->_0, buf);
    } else if (auto it = val.as<rust::Foo::Point>()) {
        _ffi_write(int32_t(2), buf);
        _ffi_write(it->x, buf);
        _ffi_write(it->y, buf);
    } else if (auto it = val.as<rust::Foo::Nested>()) {
        _ffi_write(int32_t(3), buf);
        _ffi_box_Foo_to_rust(std::move(*it->_0), buf);
    } else {
        abort();
    }
}

void _ffi_vec_Foo_to_rust(std::vector<rust::Foo>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_enum_Foo_to_rust(std::move(item), buf);
    }
}

const void* _ffi_vec_to_rust(const std::vector<uint8_t>& vec) {
    return memcpy(_ffi_alloc(vec.size()), vec.data(), vec.size());
}

} // namespace

bool rust::detail::Foo__Nested::operator == (const rust::detail::Foo__Nested& f) const {
    return *_0 == *f._0;
}

bool rust::detail::Foo__Point::operator == (const rust::detail::Foo__Point& f) const {
    return x == f.x && y == f.y;
}

bool rust::detail::Foo__Single::operator == (const rust::detail::Foo__Single& f) const {
    return _0 == f._0;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}

bool rust::set_tests(std::vector<rust::Foo> tests) {
    std::vector<uint8_t> buf;
    auto tests_len = tests.size();
    _ffi_vec_Foo_to_rust(std::move(tests), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    return _ffi_fn_set_tests(buf_ptr, tests_len);
}
