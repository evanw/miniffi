// This file was generated by miniffi v0.1.0. Do not edit.

#[allow(non_snake_case)]
fn _ffi_box_Tree_from_js(end: &mut *const u8) -> Box<Tree> {
    Box::new(Tree {
        value: _ffi_read::<i32>(end),
        left: _ffi_read::<bool>(end).then(|| _ffi_box_Tree_from_js(end)),
        right: _ffi_read::<bool>(end).then(|| _ffi_box_Tree_from_js(end))
    })
}

fn _ffi_box_box_box_i32_from_js(end: &mut *const u8) -> Box<Box<Box<i32>>> {
    Box::new(_ffi_box_box_i32_from_js(end))
}

fn _ffi_box_box_i32_from_js(end: &mut *const u8) -> Box<Box<i32>> {
    Box::new(_ffi_box_i32_from_js(end))
}

fn _ffi_box_i32_from_js(end: &mut *const u8) -> Box<i32> {
    Box::new(_ffi_read::<i32>(end))
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_check_nested(buf_ptr: *const u8) -> i32 {
    let mut buf_end = buf_ptr;
    let ret = check_nested(_ffi_box_box_box_i32_from_js(&mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_sum_tree(tree_value: i32, buf_ptr: *const u8, has_tree_left: bool, has_tree_right: bool) -> i32 {
    let mut buf_end = buf_ptr;
    let ret = sum_tree(Tree {
        value: tree_value,
        left: has_tree_left.then(|| _ffi_box_Tree_from_js(&mut buf_end)),
        right: has_tree_right.then(|| _ffi_box_Tree_from_js(&mut buf_end))
    });
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}
