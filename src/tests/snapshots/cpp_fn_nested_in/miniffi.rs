// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_test(x_0: i32, x_1_ptr_ptr: *const u8, buf_ptr: *const u8, x_2_len: usize) -> i32 {
    let x_1 = Foo { empty: (), ptr: std::rc::Rc::new(_ffi_rs_Rc_Bar(x_1_ptr_ptr)) };
    let mut buf_end = buf_ptr;
    let ret = test((x_0, x_1, _ffi_vec_i32_Foo_from_cpp(x_2_len, &mut buf_end)));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}

#[allow(non_camel_case_types)]
struct _ffi_rs_Rc_Bar(*const u8);

impl Drop for _ffi_rs_Rc_Bar {
    fn drop(&mut self) {
        unsafe extern "C" { fn _ffi_cpp_drop_Rc_Bar(_: *const u8); }
        unsafe { _ffi_cpp_drop_Rc_Bar(self.0) };
    }
}

impl Bar for _ffi_rs_Rc_Bar {
    fn get(&self) -> i32 {
        unsafe extern "C" { fn _ffi_cpp_Rc_Bar__get(_: *const u8) -> i32; }
        unsafe { _ffi_cpp_Rc_Bar__get(self.0) }
    }
}

#[allow(non_snake_case)]
fn _ffi_vec_i32_Foo_from_cpp(len: usize, end: &mut *const u8) -> Vec<(i32, Foo)> {
    let mut items = Vec::<(i32, Foo)>::with_capacity(len);
    for _ in 0..len {
        items.push((
            _ffi_read::<i32>(end),
            Foo { empty: (), ptr: std::rc::Rc::new(_ffi_rs_Rc_Bar(_ffi_read::<*const u8>(end))) }
        ));
    }
    items
}
