// This file was generated by miniffi v0.1.0. Do not edit.

enum Foo : Equatable {
    case Empty
    case Single(Int32)
    case Point(x: Int32, y: Int32)
    indirect case Nested(Foo)
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func get_tests() -> [Foo] {
    let multi_ret = _ffi_fn_get_tests()
    let buf_ptr = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_len = multi_ret._2
    var buf_end = buf_ptr!
    let ret = _ffi_vec_Foo_from_rust(Int(ret_len), &buf_end)
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

private func _ffi_box_Foo_from_rust(_ end: inout UnsafeRawPointer) -> Foo {
    return _ffi_enum_Foo_from_rust(&end)
}

private func _ffi_read<T>(_ ptr: inout UnsafeRawPointer) -> T {
    let val = ptr.loadUnaligned(fromByteOffset: 0, as: T.self)
    ptr = ptr.advanced(by: MemoryLayout<T>.size)
    return val
}

private func _ffi_enum_Foo_from_rust(_ end: inout UnsafeRawPointer) -> Foo {
    switch _ffi_read(&end) as Int32 {
        case 0: return .Empty
        case 1: return .Single(_ffi_read(&end) as Int32)
        case 2: return .Point(x: _ffi_read(&end) as Int32, y: _ffi_read(&end) as Int32)
        case 3: return .Nested(_ffi_box_Foo_from_rust(&end))
        default: fatalError()
    }
}

private func _ffi_vec_Foo_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Foo] {
    var items: [Foo] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_enum_Foo_from_rust(&end))
    }
    return items
}
