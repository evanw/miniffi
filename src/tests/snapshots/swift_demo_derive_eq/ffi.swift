// This file was generated by miniffi v0.1.0. Do not edit.

enum EnumBoxTup : Equatable {
    case Foo((Int32, Int32))
    case Bar
    case Baz(x: Int32, y: Int32)

    static func == (a: EnumBoxTup, b: EnumBoxTup) -> Bool {
        switch (a, b) {
        case let (.Foo(a0), .Foo(b0)):
            return a0.0 == b0.0 && a0.1 == b0.1
        case (.Bar, .Bar):
            return true
        case let (.Baz(x: ax, y: ay), .Baz(x: bx, y: by)):
            return ax == bx && ay == by
        default:
            return false
        }
    }
}

enum EnumVecTup : Equatable {
    case Foo([(Int32, Int32)])
    case Bar
    case Baz(x: Int32, y: Int32)

    static func == (a: EnumVecTup, b: EnumVecTup) -> Bool {
        switch (a, b) {
        case let (.Foo(a0), .Foo(b0)):
            return a0.elementsEqual(b0, by: { a, b in a.0 == b.0 && a.1 == b.1 })
        case (.Bar, .Bar):
            return true
        case let (.Baz(x: ax, y: ay), .Baz(x: bx, y: by)):
            return ax == bx && ay == by
        default:
            return false
        }
    }
}

enum EnumOptTup : Equatable {
    case Foo((Int32, Int32)?)
    case Bar
    case Baz(x: Int32, y: Int32)

    static func == (a: EnumOptTup, b: EnumOptTup) -> Bool {
        switch (a, b) {
        case let (.Foo(a0), .Foo(b0)):
            return { if let a = a0, let b = b0 { a.0 == b.0 && a.1 == b.1 } else { a0 == nil && b0 == nil } }()
        case (.Bar, .Bar):
            return true
        case let (.Baz(x: ax, y: ay), .Baz(x: bx, y: by)):
            return ax == bx && ay == by
        default:
            return false
        }
    }
}

struct EmptyStruct : Equatable {
}

struct BoxTup0 : Equatable {
    var _0: ()

    static func == (a: BoxTup0, b: BoxTup0) -> Bool {
        return true
    }
}

struct BoxTup1 : Equatable {
    var _0: Int32
}

struct BoxTup2 : Equatable {
    var _0: (Int32, Int32)

    static func == (a: BoxTup2, b: BoxTup2) -> Bool {
        return a._0.0 == b._0.0 && a._0.1 == b._0.1
    }
}

struct VecTup0 : Equatable {
    var _0: [()]

    static func == (a: VecTup0, b: VecTup0) -> Bool {
        return a._0.count == b._0.count
    }
}

struct VecTup1 : Equatable {
    var _0: [Int32]
}

struct VecTup2 : Equatable {
    var _0: [(Int32, Int32)]

    static func == (a: VecTup2, b: VecTup2) -> Bool {
        return a._0.elementsEqual(b._0, by: { a, b in a.0 == b.0 && a.1 == b.1 })
    }
}

struct OptTup0 : Equatable {
    var _0: ()?

    static func == (a: OptTup0, b: OptTup0) -> Bool {
        return (a._0 != nil) == (b._0 != nil)
    }
}

struct OptTup1 : Equatable {
    var _0: Int32?
}

struct OptTup2 : Equatable {
    var _0: (Int32, Int32)?

    static func == (a: OptTup2, b: OptTup2) -> Bool {
        return { if let a = a._0, let b = b._0 { a.0 == b.0 && a.1 == b.1 } else { a._0 == nil && b._0 == nil } }()
    }
}

struct TupBox : Equatable {
    var _0: (Int32, Bool)

    static func == (a: TupBox, b: TupBox) -> Bool {
        return a._0.0 == b._0.0 && a._0.1 == b._0.1
    }
}

struct VecBox : Equatable {
    var _0: [Int32]
}

struct BoxVec : Equatable {
    var _0: [Int32]
}

struct OptBox : Equatable {
    var _0: Int32?
}

struct BoxOpt : Equatable {
    var _0: Int32?
}

struct VecBoxVec : Equatable {
    var _0: [[Int32]]
}

struct BoxVecBox : Equatable {
    var _0: [Int32]
}

struct OptBoxOpt : Equatable {
    var _0: Int32??
}

struct BoxOptBox : Equatable {
    var _0: Int32?
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func empty_tuple(_ x: ()) -> () {
    _ffi_fn_empty_tuple()
    return ()
}

func empty_struct(_ x: EmptyStruct) -> EmptyStruct {
    _ffi_fn_empty_struct()
    return EmptyStruct()
}

func box_tup_0(_ x: BoxTup0) -> BoxTup0 {
    var buf = ContiguousArray<UInt8>()
    _ffi_box__to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_tup_0(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxTup0(_0: _ffi_box__from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func box_tup_1(_ x: BoxTup1) -> BoxTup1 {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_tup_1(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxTup1(_0: _ffi_box_i32_from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func box_tup_2(_ x: BoxTup2) -> BoxTup2 {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_i32_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_tup_2(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxTup2(_0: _ffi_box_i32_i32_from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func vec_tup_0(_ x: VecTup0) -> VecTup0 {
    var buf = ContiguousArray<UInt8>()
    let x_0_len = UInt(x._0.count)
    _ffi_vec__to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_vec_tup_0(_ffi_vec_to_rust(buf), x_0_len)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_0_len = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = VecTup0(_0: _ffi_vec__from_rust(Int(ret_0_len), &buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func vec_tup_1(_ x: VecTup1) -> VecTup1 {
    var buf = ContiguousArray<UInt8>()
    let x_0_len = UInt(x._0.count)
    _ffi_vec_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_vec_tup_1(_ffi_vec_to_rust(buf), x_0_len)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_0_len = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = VecTup1(_0: _ffi_vec_i32_from_rust(Int(ret_0_len), &buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func vec_tup_2(_ x: VecTup2) -> VecTup2 {
    var buf = ContiguousArray<UInt8>()
    let x_0_len = UInt(x._0.count)
    _ffi_vec_i32_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_vec_tup_2(_ffi_vec_to_rust(buf), x_0_len)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_0_len = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = VecTup2(_0: _ffi_vec_i32_i32_from_rust(Int(ret_0_len), &buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func opt_tup_0(_ x: OptTup0) -> OptTup0 {
    let buf = ContiguousArray<UInt8>()
    let has_x_0 = x._0 != nil
    let multi_ret = _ffi_fn_opt_tup_0(_ffi_vec_to_rust(buf), has_x_0)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let has_ret_0 = multi_ret._2
    let ret = OptTup0(_0: has_ret_0 ? () : nil)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func opt_tup_1(_ x: OptTup1) -> OptTup1 {
    var buf = ContiguousArray<UInt8>()
    let has_x_0 = x._0 != nil
    if let x_0_val = x._0 {
        _ffi_write(x_0_val, &buf)
    }
    let multi_ret = _ffi_fn_opt_tup_1(_ffi_vec_to_rust(buf), has_x_0)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let has_ret_0 = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = OptTup1(_0: has_ret_0 ? _ffi_read(&buf_end2) as Int32 : nil)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func opt_tup_2(_ x: OptTup2) -> OptTup2 {
    var buf = ContiguousArray<UInt8>()
    let has_x_0 = x._0 != nil
    if let x_0_val = x._0 {
        _ffi_write(x_0_val.0, &buf)
        _ffi_write(x_0_val.1, &buf)
    }
    let multi_ret = _ffi_fn_opt_tup_2(_ffi_vec_to_rust(buf), has_x_0)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let has_ret_0 = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = OptTup2(_0: has_ret_0 ? (_ffi_read(&buf_end2) as Int32, _ffi_read(&buf_end2) as Int32) : nil)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func enum_box_tup(_ x: EnumBoxTup) -> EnumBoxTup {
    var buf = ContiguousArray<UInt8>()
    _ffi_enum_EnumBoxTup_to_rust(x, &buf)
    let multi_ret = _ffi_fn_enum_box_tup(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = _ffi_enum_EnumBoxTup_from_rust(&buf_end2)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func enum_vec_tup(_ x: EnumVecTup) -> EnumVecTup {
    var buf = ContiguousArray<UInt8>()
    _ffi_enum_EnumVecTup_to_rust(x, &buf)
    let multi_ret = _ffi_fn_enum_vec_tup(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = _ffi_enum_EnumVecTup_from_rust(&buf_end2)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func enum_opt_tup(_ x: EnumOptTup) -> EnumOptTup {
    var buf = ContiguousArray<UInt8>()
    _ffi_enum_EnumOptTup_to_rust(x, &buf)
    let multi_ret = _ffi_fn_enum_opt_tup(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = _ffi_enum_EnumOptTup_from_rust(&buf_end2)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func tup_box(_ x: TupBox) -> TupBox {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_i32_to_rust2(x._0.0, &buf)
    _ffi_box_bool_to_rust(x._0.1, &buf)
    let multi_ret = _ffi_fn_tup_box(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = TupBox(_0: (_ffi_box_i32_from_rust2(&buf_end2), _ffi_box_bool_from_rust(&buf_end2)))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func vec_box(_ x: VecBox) -> VecBox {
    var buf = ContiguousArray<UInt8>()
    let x_0_len = UInt(x._0.count)
    _ffi_vec_box_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_vec_box(_ffi_vec_to_rust(buf), x_0_len)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_0_len = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = VecBox(_0: _ffi_vec_box_i32_from_rust(Int(ret_0_len), &buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func box_vec(_ x: BoxVec) -> BoxVec {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_vec_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_vec(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxVec(_0: _ffi_box_vec_i32_from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func opt_box(_ x: OptBox) -> OptBox {
    var buf = ContiguousArray<UInt8>()
    let has_x_0 = x._0 != nil
    if let x_0_val = x._0 {
        _ffi_box_i32_to_rust2(x_0_val, &buf)
    }
    let multi_ret = _ffi_fn_opt_box(_ffi_vec_to_rust(buf), has_x_0)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let has_ret_0 = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = OptBox(_0: has_ret_0 ? _ffi_box_i32_from_rust2(&buf_end2) : nil)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func box_opt(_ x: BoxOpt) -> BoxOpt {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_option_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_opt(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxOpt(_0: _ffi_box_option_i32_from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func vec_box_vec(_ x: VecBoxVec) -> VecBoxVec {
    var buf = ContiguousArray<UInt8>()
    let x_0_len = UInt(x._0.count)
    _ffi_vec_box_vec_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_vec_box_vec(_ffi_vec_to_rust(buf), x_0_len)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_0_len = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = VecBoxVec(_0: _ffi_vec_box_vec_i32_from_rust(Int(ret_0_len), &buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func box_vec_box(_ x: BoxVecBox) -> BoxVecBox {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_vec_box_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_vec_box(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxVecBox(_0: _ffi_box_vec_box_i32_from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func opt_box_opt(_ x: OptBoxOpt) -> OptBoxOpt {
    var buf = ContiguousArray<UInt8>()
    let has_x_0 = x._0 != nil
    if let x_0_val = x._0 {
        _ffi_box_option_i32_to_rust(x_0_val, &buf)
    }
    let multi_ret = _ffi_fn_opt_box_opt(_ffi_vec_to_rust(buf), has_x_0)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let has_ret_0 = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = OptBoxOpt(_0: has_ret_0 ? _ffi_box_option_i32_from_rust(&buf_end2) : nil)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

func box_opt_box(_ x: BoxOptBox) -> BoxOptBox {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_option_box_i32_to_rust(x._0, &buf)
    let multi_ret = _ffi_fn_box_opt_box(_ffi_vec_to_rust(buf))
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    var buf_end2 = buf_ptr2!
    let ret = BoxOptBox(_0: _ffi_box_option_box_i32_from_rust(&buf_end2))
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

private func _ffi_box__from_rust(_ end: inout UnsafeRawPointer) -> () {
    return ()
}

private func _ffi_box__to_rust(_ val: (), _ buf: inout ContiguousArray<UInt8>) {
}

private func _ffi_box_bool_from_rust(_ end: inout UnsafeRawPointer) -> Bool {
    return _ffi_read(&end) as Bool
}

private func _ffi_box_bool_to_rust(_ val: Bool, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val, &buf)
}

private func _ffi_box_i32_from_rust(_ end: inout UnsafeRawPointer) -> Int32 {
    return _ffi_read(&end) as Int32
}

private func _ffi_box_i32_from_rust2(_ end: inout UnsafeRawPointer) -> Int32 {
    return _ffi_read(&end) as Int32
}

private func _ffi_box_i32_i32_from_rust(_ end: inout UnsafeRawPointer) -> (Int32, Int32) {
    return (_ffi_read(&end) as Int32, _ffi_read(&end) as Int32)
}

private func _ffi_box_i32_i32_to_rust(_ val: (Int32, Int32), _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val.0, &buf)
    _ffi_write(val.1, &buf)
}

private func _ffi_box_i32_to_rust(_ val: Int32, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val, &buf)
}

private func _ffi_box_i32_to_rust2(_ val: Int32, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val, &buf)
}

private func _ffi_box_option_box_i32_from_rust(_ end: inout UnsafeRawPointer) -> Int32? {
    return _ffi_read(&end) as Bool ? _ffi_box_i32_from_rust2(&end) : nil
}

private func _ffi_box_option_box_i32_to_rust(_ val: Int32?, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val != nil, &buf)
    if let val_val = val {
        _ffi_box_i32_to_rust2(val_val, &buf)
    }
}

private func _ffi_box_option_i32_from_rust(_ end: inout UnsafeRawPointer) -> Int32? {
    return _ffi_read(&end) as Bool ? _ffi_read(&end) as Int32 : nil
}

private func _ffi_box_option_i32_to_rust(_ val: Int32?, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val != nil, &buf)
    if let val_val = val {
        _ffi_write(val_val, &buf)
    }
}

private func _ffi_box_vec_box_i32_from_rust(_ end: inout UnsafeRawPointer) -> [Int32] {
    return _ffi_vec_box_i32_from_rust(Int(_ffi_read(&end) as UInt), &end)
}

private func _ffi_box_vec_box_i32_to_rust(_ val: [Int32], _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(UInt(val.count), &buf)
    _ffi_vec_box_i32_to_rust(val, &buf)
}

private func _ffi_box_vec_i32_from_rust(_ end: inout UnsafeRawPointer) -> [Int32] {
    return _ffi_vec_i32_from_rust2(Int(_ffi_read(&end) as UInt), &end)
}

private func _ffi_box_vec_i32_to_rust(_ val: [Int32], _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(UInt(val.count), &buf)
    _ffi_vec_i32_to_rust2(val, &buf)
}

private func _ffi_read<T>(_ ptr: inout UnsafeRawPointer) -> T {
    let val = ptr.loadUnaligned(fromByteOffset: 0, as: T.self)
    ptr = ptr.advanced(by: MemoryLayout<T>.size)
    return val
}

private func _ffi_enum_EnumBoxTup_from_rust(_ end: inout UnsafeRawPointer) -> EnumBoxTup {
    switch _ffi_read(&end) as Int32 {
        case 0: return .Foo(_ffi_box_i32_i32_from_rust(&end))
        case 1: return .Bar
        case 2: return .Baz(x: _ffi_read(&end) as Int32, y: _ffi_read(&end) as Int32)
        default: fatalError()
    }
}

private func _ffi_enum_EnumBoxTup_to_rust(_ val: EnumBoxTup, _ buf: inout ContiguousArray<UInt8>) {
    switch val {
    case let .Foo(x):
        _ffi_write(0 as Int32, &buf)
        _ffi_box_i32_i32_to_rust(x, &buf)
    case .Bar:
        _ffi_write(1 as Int32, &buf)
    case let .Baz(x, y):
        _ffi_write(2 as Int32, &buf)
        _ffi_write(x, &buf)
        _ffi_write(y, &buf)
    }
}

private func _ffi_enum_EnumOptTup_from_rust(_ end: inout UnsafeRawPointer) -> EnumOptTup {
    switch _ffi_read(&end) as Int32 {
        case 0: return .Foo(_ffi_read(&end) as Bool ? (_ffi_read(&end) as Int32, _ffi_read(&end) as Int32) : nil)
        case 1: return .Bar
        case 2: return .Baz(x: _ffi_read(&end) as Int32, y: _ffi_read(&end) as Int32)
        default: fatalError()
    }
}

private func _ffi_enum_EnumOptTup_to_rust(_ val: EnumOptTup, _ buf: inout ContiguousArray<UInt8>) {
    switch val {
    case let .Foo(x):
        _ffi_write(0 as Int32, &buf)
        _ffi_write(x != nil, &buf)
        if let x_val = x {
            _ffi_write(x_val.0, &buf)
            _ffi_write(x_val.1, &buf)
        }
    case .Bar:
        _ffi_write(1 as Int32, &buf)
    case let .Baz(x, y):
        _ffi_write(2 as Int32, &buf)
        _ffi_write(x, &buf)
        _ffi_write(y, &buf)
    }
}

private func _ffi_enum_EnumVecTup_from_rust(_ end: inout UnsafeRawPointer) -> EnumVecTup {
    switch _ffi_read(&end) as Int32 {
        case 0: return .Foo(_ffi_vec_i32_i32_from_rust(Int(_ffi_read(&end) as UInt), &end))
        case 1: return .Bar
        case 2: return .Baz(x: _ffi_read(&end) as Int32, y: _ffi_read(&end) as Int32)
        default: fatalError()
    }
}

private func _ffi_enum_EnumVecTup_to_rust(_ val: EnumVecTup, _ buf: inout ContiguousArray<UInt8>) {
    switch val {
    case let .Foo(x):
        _ffi_write(0 as Int32, &buf)
        _ffi_write(UInt(x.count), &buf)
        _ffi_vec_i32_i32_to_rust(x, &buf)
    case .Bar:
        _ffi_write(1 as Int32, &buf)
    case let .Baz(x, y):
        _ffi_write(2 as Int32, &buf)
        _ffi_write(x, &buf)
        _ffi_write(y, &buf)
    }
}

private func _ffi_vec__from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [()] {
    var items: [()] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(())
    }
    return items
}

private func _ffi_vec__to_rust(_ items: [()], _ buf: inout ContiguousArray<UInt8>) {
}

private func _ffi_vec_box_i32_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Int32] {
    var items: [Int32] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_box_i32_from_rust2(&end))
    }
    return items
}

private func _ffi_vec_box_i32_to_rust(_ items: [Int32], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_box_i32_to_rust2(item, &buf)
    }
}

private func _ffi_vec_box_vec_i32_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [[Int32]] {
    var items: [[Int32]] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_box_vec_i32_from_rust(&end))
    }
    return items
}

private func _ffi_vec_box_vec_i32_to_rust(_ items: [[Int32]], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_box_vec_i32_to_rust(item, &buf)
    }
}

private func _ffi_vec_i32_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Int32] {
    var items: [Int32] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_read(&end) as Int32)
    }
    return items
}

private func _ffi_vec_i32_from_rust2(_ len: Int, _ end: inout UnsafeRawPointer) -> [Int32] {
    var items: [Int32] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_read(&end) as Int32)
    }
    return items
}

private func _ffi_vec_i32_i32_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [(Int32, Int32)] {
    var items: [(Int32, Int32)] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append((_ffi_read(&end) as Int32, _ffi_read(&end) as Int32))
    }
    return items
}

private func _ffi_vec_i32_i32_to_rust(_ items: [(Int32, Int32)], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item.0, &buf)
        _ffi_write(item.1, &buf)
    }
}

private func _ffi_vec_i32_to_rust(_ items: [Int32], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item, &buf)
    }
}

private func _ffi_vec_i32_to_rust2(_ items: [Int32], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item, &buf)
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
