// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_Box_Handler__on_draw(_self: *const u8, canvas_ptr: *const u8) {
    let _self = unsafe { &*(_self as *const Box<dyn Handler>) };
    _self.on_draw(Box::new(_ffi_rs_Box_Canvas(canvas_ptr)));
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_drop_Box_Handler(ptr: *const u8) {
    drop(unsafe { Box::from_raw(ptr as *mut Box<dyn Handler>) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_create_app(platform_ptr: *const u8) {
    create_app(Box::new(_ffi_rs_Box_Platform(platform_ptr)));
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[repr(C)]
struct _ffi_ret_2_i32(i32, i32);

#[repr(C)]
struct _ffi_ret_ptr_usize(*const u8, usize);

#[allow(non_camel_case_types)]
struct _ffi_rs_Box_Canvas(*const u8);

impl Drop for _ffi_rs_Box_Canvas {
    fn drop(&mut self) {
        unsafe extern "C" { fn _ffi_cpp_drop_Box_Canvas(_: *const u8); }
        unsafe { _ffi_cpp_drop_Box_Canvas(self.0) };
    }
}

impl Canvas for _ffi_rs_Box_Canvas {
    fn draw_text_runs(&self, runs: Vec<TextRun>) {
        unsafe extern "C" { fn _ffi_cpp_Box_Canvas__draw_text_runs(_: *const u8, buf_ptr: *const u8, buf_cap: usize, runs_len: usize); }
        let mut buf = Vec::<u8>::new();
        let runs_len = runs.len();
        _ffi_vec_TextRun_to_cpp(runs, &mut buf);
        let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
        unsafe { _ffi_cpp_Box_Canvas__draw_text_runs(self.0, buf_ptr, buf_cap, runs_len) };
    }
}

#[allow(non_camel_case_types)]
struct _ffi_rs_Box_Platform(*const u8);

impl Drop for _ffi_rs_Box_Platform {
    fn drop(&mut self) {
        unsafe extern "C" { fn _ffi_cpp_drop_Box_Platform(_: *const u8); }
        unsafe { _ffi_cpp_drop_Box_Platform(self.0) };
    }
}

impl Platform for _ffi_rs_Box_Platform {
    fn create_window(&self) -> std::rc::Rc<dyn Window> {
        unsafe extern "C" { fn _ffi_cpp_Box_Platform__create_window(_: *const u8) -> *const u8; }
        let ret_ptr = unsafe { _ffi_cpp_Box_Platform__create_window(self.0) };
        std::rc::Rc::new(_ffi_rs_Rc_Window(ret_ptr))
    }
}

#[allow(non_camel_case_types)]
struct _ffi_rs_Rc_Window(*const u8);

impl Drop for _ffi_rs_Rc_Window {
    fn drop(&mut self) {
        unsafe extern "C" { fn _ffi_cpp_drop_Rc_Window(_: *const u8); }
        unsafe { _ffi_cpp_drop_Rc_Window(self.0) };
    }
}

impl Window for _ffi_rs_Rc_Window {
    fn get_title(&self) -> String {
        unsafe extern "C" { fn _ffi_cpp_Rc_Window__get_title(_: *const u8) -> _ffi_ret_ptr_usize; }
        let multi_ret = unsafe { _ffi_cpp_Rc_Window__get_title(self.0) };
        let ret_ptr = multi_ret.0;
        let ret_len = multi_ret.1;
        _ffi_string_from_host(ret_ptr, ret_len)
    }

    fn set_title(&self, title: &str) {
        unsafe extern "C" { fn _ffi_cpp_Rc_Window__set_title(_: *const u8, title_ptr: *const u8, title_len: usize, title_cap: usize); }
        let (title_ptr, title_len, title_cap) = _ffi_string_to_host(title.into());
        unsafe { _ffi_cpp_Rc_Window__set_title(self.0, title_ptr, title_len, title_cap) };
    }

    fn get_size(&self) -> (i32, i32) {
        unsafe extern "C" { fn _ffi_cpp_Rc_Window__get_size(_: *const u8) -> _ffi_ret_2_i32; }
        let multi_ret = unsafe { _ffi_cpp_Rc_Window__get_size(self.0) };
        let ret_0 = multi_ret.0;
        let ret_1 = multi_ret.1;
        (ret_0, ret_1)
    }

    fn set_size(&self, width: i32, height: i32) {
        unsafe extern "C" { fn _ffi_cpp_Rc_Window__set_size(_: *const u8, width: i32, height: i32); }
        unsafe { _ffi_cpp_Rc_Window__set_size(self.0, width, height) };
    }

    fn set_handler(&self, handler: Box<dyn Handler>) {
        unsafe extern "C" { fn _ffi_cpp_Rc_Window__set_handler(_: *const u8, handler_ptr: *const u8); }
        unsafe { _ffi_cpp_Rc_Window__set_handler(self.0, Box::into_raw(Box::new(handler)) as *const u8) };
    }

    fn child_window(&self) -> std::rc::Rc<dyn Window> {
        unsafe extern "C" { fn _ffi_cpp_Rc_Window__child_window(_: *const u8) -> *const u8; }
        let ret_ptr = unsafe { _ffi_cpp_Rc_Window__child_window(self.0) };
        std::rc::Rc::new(_ffi_rs_Rc_Window(ret_ptr))
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_string_from_host(ptr: *const u8, len: usize) -> String {
    unsafe { String::from_raw_parts(ptr as *mut u8, len, len) }
}

fn _ffi_string_to_host(buf: String) -> (*const u8, usize, usize) {
    let buf = std::mem::ManuallyDrop::new(buf.into_bytes());
    (buf.as_ptr(), buf.len(), buf.capacity())
}

#[allow(non_snake_case)]
fn _ffi_vec_TextRun_to_cpp(items: Vec<TextRun>, buf: &mut Vec<u8>) {
    for item in items {
        let (item_text_ptr, item_text_len, item_text_cap) = _ffi_string_to_host(item.text);
        _ffi_write(item_text_ptr, buf);
        _ffi_write(item_text_len, buf);
        _ffi_write(item_text_cap, buf);
        _ffi_write(item.rect.x, buf);
        _ffi_write(item.rect.y, buf);
        _ffi_write(item.rect.w, buf);
        _ffi_write(item.rect.h, buf);
    }
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = &raw const val as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}
