// This file was generated by miniffi v0.1.0. Do not edit.

protocol Trait: AnyObject {
    func get() -> Int32
}

struct Example {
    var box_ptr: Trait
    var rc_ptr: Trait
    var text: String
    var vec_box: [Trait]
    var vec_rc: [Trait]
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func test(_ vec: [Example]) -> [Example] {
    var buf = ContiguousArray<UInt8>()
    let vec_len = UInt(vec.count)
    _ffi_vec_Example_to_rust(vec, &buf)
    let multi_ret = _ffi_fn_test(_ffi_vec_to_rust(buf), vec_len)
    let buf_ptr2 = multi_ret._0
    let buf_cap = multi_ret._1
    let ret_len = multi_ret._2
    var buf_end2 = buf_ptr2!
    let ret = _ffi_vec_Example_from_rust(Int(ret_len), &buf_end2)
    _ffi_dealloc(buf_ptr2, buf_cap)
    return ret
}

private class _ffi_Box_Trait : Trait {
    private var _ffi: UnsafeRawPointer?

    init(_ ptr: UnsafeRawPointer?) {
        _ffi = ptr
    }

    deinit {
        _ffi_rs_drop_Box_Trait(_ffi)
    }

    func get() -> Int32 {
        return _ffi_Box_Trait__get(_ffi)
    }
}

private class _ffi_Rc_Trait : Trait {
    private var _ffi: UnsafeRawPointer?

    init(_ ptr: UnsafeRawPointer?) {
        _ffi = ptr
    }

    deinit {
        _ffi_rs_drop_Rc_Trait(_ffi)
    }

    func get() -> Int32 {
        return _ffi_Rc_Trait__get(_ffi)
    }
}

private func _ffi_read<T>(_ ptr: inout UnsafeRawPointer) -> T {
    let val = ptr.loadUnaligned(fromByteOffset: 0, as: T.self)
    ptr = ptr.advanced(by: MemoryLayout<T>.size)
    return val
}

private func _ffi_string_from_rust(_ ptr: UnsafeRawPointer?, _ len: Int, _ cap: UInt) -> String {
    let buf = UnsafeBufferPointer(start: ptr!.assumingMemoryBound(to: UInt8.self), count: len)
    let str = String(decoding: buf, as: UTF8.self)
    _ffi_dealloc(ptr, cap)
    return str
}

private func _ffi_string_to_rust(_ str: String) -> (UnsafeRawPointer?, UInt) {
    var str = str
    return str.withUTF8 { str in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(str.count), count: str.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: str.baseAddress, count: str.count))
        return (UnsafeRawPointer(buf.baseAddress), UInt(buf.count))
    }
}

@_cdecl("_ffi_swift_Trait__get")
func _ffi_swift_Trait__get(_self: UnsafeRawPointer?) -> Int32 {
    let _self = Unmanaged<AnyObject>.fromOpaque(_self!).takeUnretainedValue() as! Trait
    return _self.get()
}

@_cdecl("_ffi_swift_drop")
func _ffi_swift_drop(ptr: UnsafeRawPointer?) {
    _ = Unmanaged<AnyObject>.fromOpaque(ptr!).takeRetainedValue()
}

private func _ffi_vec_Example_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Example] {
    var items: [Example] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(Example(
            box_ptr: _ffi_Box_Trait(_ffi_read(&end) as UnsafeRawPointer?),
            rc_ptr: _ffi_Rc_Trait(_ffi_read(&end) as UnsafeRawPointer?),
            text: _ffi_string_from_rust(_ffi_read(&end) as UnsafeRawPointer?, Int(_ffi_read(&end) as UInt), _ffi_read(&end) as UInt),
            vec_box: _ffi_vec_box_dyn_Trait_from_rust(Int(_ffi_read(&end) as UInt), &end),
            vec_rc: _ffi_vec_rc_dyn_Trait_from_rust(Int(_ffi_read(&end) as UInt), &end)
        ))
    }
    return items
}

private func _ffi_vec_Example_to_rust(_ items: [Example], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(UnsafeRawPointer(Unmanaged.passRetained(item.box_ptr as AnyObject).toOpaque()), &buf)
        _ffi_write(UnsafeRawPointer(Unmanaged.passRetained(item.rc_ptr as AnyObject).toOpaque()), &buf)
        let (item_text_ptr, item_text_len) = _ffi_string_to_rust(item.text);
        _ffi_write(item_text_ptr, &buf)
        _ffi_write(item_text_len, &buf)
        _ffi_write(UInt(item.vec_box.count), &buf)
        _ffi_vec_box_dyn_Trait_to_rust(item.vec_box, &buf)
        _ffi_write(UInt(item.vec_rc.count), &buf)
        _ffi_vec_rc_dyn_Trait_to_rust(item.vec_rc, &buf)
    }
}

private func _ffi_vec_box_dyn_Trait_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Trait] {
    var items: [Trait] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_Box_Trait(_ffi_read(&end) as UnsafeRawPointer?))
    }
    return items
}

private func _ffi_vec_box_dyn_Trait_to_rust(_ items: [Trait], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(UnsafeRawPointer(Unmanaged.passRetained(item as AnyObject).toOpaque()), &buf)
    }
}

private func _ffi_vec_rc_dyn_Trait_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Trait] {
    var items: [Trait] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(_ffi_Rc_Trait(_ffi_read(&end) as UnsafeRawPointer?))
    }
    return items
}

private func _ffi_vec_rc_dyn_Trait_to_rust(_ items: [Trait], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(UnsafeRawPointer(Unmanaged.passRetained(item as AnyObject).toOpaque()), &buf)
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
