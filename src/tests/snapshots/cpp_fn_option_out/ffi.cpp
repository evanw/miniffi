// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_ptr_2_usize {
    const void* _0;
    uintptr_t _1;
    uintptr_t _2;
};

struct _ffi_ret_ptr_usize_bool {
    const void* _0;
    uintptr_t _1;
    bool _2;
};

extern "C" {

void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_int(bool x, int32_t y);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_opt_int(bool x, bool y, int32_t z);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_vec_opt_string(int32_t n);
uintptr_t _ffi_fn_rust_mem_leaked();
_ffi_ret_ptr_2_usize _ffi_fn_vec_opt_int(int32_t n);

} // extern "C"

namespace {

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

std::string _ffi_string_from_rust(const char* ptr, uintptr_t len, uintptr_t cap) {
    std::string str(ptr, len);
    _ffi_dealloc(ptr, cap);
    return str;
}

std::vector<std::optional<std::string>> _ffi_vec_option_string_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::optional<std::string>> items;
    items.reserve(len);
    while (items.size() < len) {
        std::optional<std::string> item;
        if (_ffi_read<bool>(end)) {
            auto item_val_ptr = _ffi_read<const char*>(end);
            auto item_val_len = _ffi_read<uintptr_t>(end);
            auto item_val_cap = _ffi_read<uintptr_t>(end);
            item = std::make_optional(_ffi_string_from_rust(item_val_ptr, item_val_len, item_val_cap));
        }
        items.emplace_back(std::move(item));
    }
    return items;
}

std::vector<std::optional<int32_t>> _ffi_vec_option_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::optional<int32_t>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = _ffi_read<bool>(end) ? std::make_optional(_ffi_read<int32_t>(end)) : std::nullopt;
        items.emplace_back(std::move(item));
    }
    return items;
}

} // namespace

std::optional<int32_t> rust::opt_int(bool x, int32_t y) {
    auto multi_ret = _ffi_fn_opt_int(x, y);
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret = has_ret ? std::make_optional(_ffi_read<int32_t>(buf_end)) : std::nullopt;
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

std::optional<std::optional<int32_t>> rust::opt_opt_int(bool x, bool y, int32_t z) {
    auto multi_ret = _ffi_fn_opt_opt_int(x, y, z);
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret = has_ret ? std::make_optional(_ffi_read<bool>(buf_end) ? std::make_optional(_ffi_read<int32_t>(buf_end)) : std::nullopt) : std::nullopt;
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

std::optional<std::vector<std::optional<std::string>>> rust::opt_vec_opt_string(int32_t n) {
    auto multi_ret = _ffi_fn_opt_vec_opt_string(n);
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    std::optional<std::vector<std::optional<std::string>>> ret;
    if (has_ret) {
        auto ret_val_len = _ffi_read<uintptr_t>(buf_end);
        ret = std::make_optional(_ffi_vec_option_string_from_rust(ret_val_len, buf_end));
    }
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}

std::vector<std::optional<int32_t>> rust::vec_opt_int(int32_t n) {
    auto multi_ret = _ffi_fn_vec_opt_int(n);
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_len = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret = _ffi_vec_option_i32_from_rust(ret_len, buf_end);
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}
