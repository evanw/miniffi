// This file was generated by miniffi v0.1.0. Do not edit.

enum Foo : Equatable {
    case Empty
    case Single(Int32)
    case Point(x: Int32, y: Int32)
    indirect case Nested(Foo)
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func set_tests(_ tests: [Foo]) -> Bool {
    var buf = ContiguousArray<UInt8>()
    let tests_len = UInt(tests.count)
    _ffi_vec_Foo_to_rust(tests, &buf)
    return _ffi_fn_set_tests(_ffi_vec_to_rust(buf), tests_len)
}

private func _ffi_box_Foo_to_rust(_ val: Foo, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_enum_Foo_to_rust(val, &buf)
}

private func _ffi_enum_Foo_to_rust(_ val: Foo, _ buf: inout ContiguousArray<UInt8>) {
    switch val {
    case .Empty:
        _ffi_write(0 as Int32, &buf)
    case let .Single(x):
        _ffi_write(1 as Int32, &buf)
        _ffi_write(x, &buf)
    case let .Point(x, y):
        _ffi_write(2 as Int32, &buf)
        _ffi_write(x, &buf)
        _ffi_write(y, &buf)
    case let .Nested(x):
        _ffi_write(3 as Int32, &buf)
        _ffi_box_Foo_to_rust(x, &buf)
    }
}

private func _ffi_vec_Foo_to_rust(_ items: [Foo], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_enum_Foo_to_rust(item, &buf)
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
