// This file was generated by miniffi v0.1.0. Do not edit.

protocol Bar: AnyObject {
    func get() -> Int32
}

struct Foo {
    var empty: ()
    var ptr: Bar
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func test(_ x: (Int32, Foo, [(Int32, Foo)])) -> Int32 {
    let x_1_ptr_ptr = UnsafeRawPointer(Unmanaged.passRetained(x.1.ptr as AnyObject).toOpaque())
    var buf = ContiguousArray<UInt8>()
    let x_2_len = UInt(x.2.count)
    _ffi_vec_i32_Foo_to_rust(x.2, &buf)
    return _ffi_fn_test(x.0, x_1_ptr_ptr, _ffi_vec_to_rust(buf), x_2_len)
}

@_cdecl("_ffi_swift_Bar__get")
func _ffi_swift_Bar__get(_self: UnsafeRawPointer?) -> Int32 {
    let _self = Unmanaged<AnyObject>.fromOpaque(_self!).takeUnretainedValue() as! Bar
    return _self.get()
}

@_cdecl("_ffi_swift_drop")
func _ffi_swift_drop(ptr: UnsafeRawPointer?) {
    _ = Unmanaged<AnyObject>.fromOpaque(ptr!).takeRetainedValue()
}

private func _ffi_vec_i32_Foo_to_rust(_ items: [(Int32, Foo)], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item.0, &buf)
        _ffi_write(UnsafeRawPointer(Unmanaged.passRetained(item.1.ptr as AnyObject).toOpaque()), &buf)
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
