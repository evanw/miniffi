// This file was generated by miniffi v0.1.0. Do not edit.

#[no_mangle]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

#[no_mangle]
extern "C" fn _ffi_fn_check_combo1() -> *const _ffi_ret_i32_ptr_4_usize {
    let ret = check_combo1();
    let ret_x = ret.x;
    let ret_x_0 = ret_x.0;
    let ret_x_0_x = ret_x_0.x;
    let ret_x_0_y = ret_x_0.y;
    let mut buf = Vec::<u8>::new();
    let ret_x_0_y_len = ret_x_0_y.len();
    _ffi_vec_Foo_to_js(ret_x_0_y, &mut buf);
    let ret_x_1 = ret_x.1;
    let ret_x_1_len = ret_x_1.len();
    _ffi_vec_Bar_to_js(ret_x_1, &mut buf);
    let ret_y = ret.y;
    let ret_y_len = ret_y.len();
    _ffi_vec__i32_f32_bool_to_js(ret_y, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    unsafe {
        _FFI_RET_I32_PTR_4_USIZE = _ffi_ret_i32_ptr_4_usize(ret_x_0_x, buf_ptr, buf_cap, ret_x_0_y_len, ret_x_1_len, ret_y_len);
        std::ptr::addr_of!(_FFI_RET_I32_PTR_4_USIZE)
    }
}

#[no_mangle]
extern "C" fn _ffi_fn_check_combo2() -> *const _ffi_ret_i32_ptr_4_usize {
    let ret = check_combo2();
    let ret_x = ret.x;
    let ret_x_0 = ret_x.0;
    let ret_x_0_x = ret_x_0.x;
    let ret_x_0_y = ret_x_0.y;
    let mut buf = Vec::<u8>::new();
    let ret_x_0_y_len = ret_x_0_y.len();
    _ffi_vec_Foo_to_js(ret_x_0_y, &mut buf);
    let ret_x_1 = ret_x.1;
    let ret_x_1_len = ret_x_1.len();
    _ffi_vec_Bar_to_js(ret_x_1, &mut buf);
    let ret_y = ret.y;
    let ret_y_len = ret_y.len();
    _ffi_vec__i32_f32_bool_to_js(ret_y, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    unsafe {
        _FFI_RET_I32_PTR_4_USIZE = _ffi_ret_i32_ptr_4_usize(ret_x_0_x, buf_ptr, buf_cap, ret_x_0_y_len, ret_x_1_len, ret_y_len);
        std::ptr::addr_of!(_FFI_RET_I32_PTR_4_USIZE)
    }
}

#[no_mangle]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[repr(C)]
struct _ffi_ret_i32_ptr_4_usize(i32, *const u8, usize, usize, usize, usize);
static mut _FFI_RET_I32_PTR_4_USIZE: _ffi_ret_i32_ptr_4_usize = _ffi_ret_i32_ptr_4_usize(0, std::ptr::null(), 0, 0, 0, 0);

#[allow(non_snake_case)]
fn _ffi_vec_Bar_to_js(items: Vec<Bar>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.x, buf);
        _ffi_write(item.y.len(), buf);
        _ffi_vec_Foo_to_js(item.y, buf);
    }
}

#[allow(non_snake_case)]
fn _ffi_vec_Foo_to_js(items: Vec<Foo>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.x.0.x, buf);
        _ffi_write(item.x.0.y.len(), buf);
        _ffi_vec_Foo_to_js(item.x.0.y, buf);
        _ffi_write(item.x.1.len(), buf);
        _ffi_vec_Bar_to_js(item.x.1, buf);
        _ffi_write(item.y.len(), buf);
        _ffi_vec__i32_f32_bool_to_js(item.y, buf);
    }
}

#[allow(non_snake_case)]
fn _ffi_vec__i32_f32_bool_to_js(items: Vec<((), (i32,), (f32, bool))>, buf: &mut Vec<u8>) {
    for item in items {
        _ = item.0;
        _ffi_write(item.1.0, buf);
        _ffi_write(item.2.0, buf);
        _ffi_write(item.2.1, buf);
    }
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = std::ptr::addr_of!(val) as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}
