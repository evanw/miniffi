// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_ptr_2_usize {
    const void* _0;
    uintptr_t _1;
    uintptr_t _2;
};

extern "C" {

void _ffi_drop_Box_Trait(const void* ptr);
void _ffi_drop_Rc_Trait(const void* ptr);
void* _ffi_alloc(uintptr_t len);
int32_t _ffi_Box_Trait__get(const void* _self);
int32_t _ffi_Rc_Trait__get(const void* _self);
uintptr_t _ffi_fn_rust_mem_leaked();
void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_ptr_2_usize _ffi_fn_test(const void* buf_ptr, uintptr_t vec_len);

} // extern "C"

namespace {

struct _ffi_Box_Trait final : rust::Trait {
    _ffi_Box_Trait(const void* ptr) : _self(ptr) {}
    virtual ~_ffi_Box_Trait() { _ffi_drop_Box_Trait(_self); }
    virtual int32_t get();
    const void* _self;
};

struct _ffi_Rc_Trait final : rust::Trait {
    _ffi_Rc_Trait(const void* ptr) : _self(ptr) {}
    virtual ~_ffi_Rc_Trait() { _ffi_drop_Rc_Trait(_self); }
    virtual int32_t get();
    const void* _self;
};

const void* _ffi_string_to_rust(const std::string& str, uintptr_t &len) {
    len = str.size();
    return memcpy(_ffi_alloc(len), str.data(), len);
}

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

std::string _ffi_string_from_rust(const char* ptr, uintptr_t len, uintptr_t cap) {
    std::string str(ptr, len);
    _ffi_dealloc(ptr, cap);
    return str;
}

std::vector<std::unique_ptr<rust::Trait>> _ffi_vec_box_dyn_Trait_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::unique_ptr<rust::Trait>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_ptr = _ffi_read<const void*>(end);
        auto item = std::unique_ptr<rust::Trait>(new _ffi_Box_Trait(item_ptr));
        items.emplace_back(std::move(item));
    }
    return items;
}

std::vector<std::shared_ptr<rust::Trait>> _ffi_vec_rc_dyn_Trait_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::shared_ptr<rust::Trait>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_ptr = _ffi_read<const void*>(end);
        auto item = std::make_shared<_ffi_Rc_Trait>(item_ptr);
        items.emplace_back(std::move(item));
    }
    return items;
}

std::vector<rust::Example> _ffi_vec_Example_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<rust::Example> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_box_ptr_ptr = _ffi_read<const void*>(end);
        auto item_box_ptr = std::unique_ptr<rust::Trait>(new _ffi_Box_Trait(item_box_ptr_ptr));
        auto item_rc_ptr_ptr = _ffi_read<const void*>(end);
        auto item_rc_ptr = std::make_shared<_ffi_Rc_Trait>(item_rc_ptr_ptr);
        auto item_text_ptr = _ffi_read<const char*>(end);
        auto item_text_len = _ffi_read<uintptr_t>(end);
        auto item_text_cap = _ffi_read<uintptr_t>(end);
        auto item_text = _ffi_string_from_rust(item_text_ptr, item_text_len, item_text_cap);
        auto item_vec_box_len = _ffi_read<uintptr_t>(end);
        auto item_vec_box = _ffi_vec_box_dyn_Trait_from_rust(item_vec_box_len, end);
        auto item_vec_rc_len = _ffi_read<uintptr_t>(end);
        auto item_vec_rc = _ffi_vec_rc_dyn_Trait_from_rust(item_vec_rc_len, end);
        auto item = rust::Example{
            std::move(item_box_ptr),
            std::move(item_rc_ptr),
            std::move(item_text),
            std::move(item_vec_box),
            std::move(item_vec_rc)
        };
        items.emplace_back(std::move(item));
    }
    return items;
}

template <typename T>
void _ffi_write(T val, std::vector<uint8_t> &buf) {
    buf.insert(buf.end(), (const uint8_t*)&val, (const uint8_t*)&val + sizeof(T));
}

void _ffi_vec_box_dyn_Trait_to_rust(std::vector<std::unique_ptr<rust::Trait>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        auto item_ptr = item.release();
        _ffi_write(item_ptr, buf);
    }
}

void _ffi_vec_rc_dyn_Trait_to_rust(std::vector<std::shared_ptr<rust::Trait>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        auto item_ptr = new std::shared_ptr<rust::Trait>(item);
        _ffi_write(item_ptr, buf);
    }
}

void _ffi_vec_Example_to_rust(std::vector<rust::Example>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        auto item_box_ptr_ptr = item.box_ptr.release();
        _ffi_write(item_box_ptr_ptr, buf);
        auto item_rc_ptr_ptr = new std::shared_ptr<rust::Trait>(item.rc_ptr);
        _ffi_write(item_rc_ptr_ptr, buf);
        uintptr_t item_text_len;
        const void* item_text_ptr = _ffi_string_to_rust(item.text, item_text_len);
        _ffi_write(item_text_ptr, buf);
        _ffi_write(item_text_len, buf);
        auto item_vec_box_len = item.vec_box.size();
        _ffi_write(item_vec_box_len, buf);
        _ffi_vec_box_dyn_Trait_to_rust(std::move(item.vec_box), buf);
        auto item_vec_rc_len = item.vec_rc.size();
        _ffi_write(item_vec_rc_len, buf);
        _ffi_vec_rc_dyn_Trait_to_rust(std::move(item.vec_rc), buf);
    }
}

const void* _ffi_vec_to_rust(const std::vector<uint8_t>& vec) {
    return memcpy(_ffi_alloc(vec.size()), vec.data(), vec.size());
}

} // namespace

extern "C" {

int32_t _ffi_cpp_Box_Trait__get(rust::Trait* _self) {
    return _self->get();
}

int32_t _ffi_cpp_Rc_Trait__get(std::shared_ptr<rust::Trait>* _self) {
    return _self->get()->get();
}

void _ffi_cpp_drop_Box_Trait(rust::Trait* self) {
    delete self;
}

void _ffi_cpp_drop_Rc_Trait(std::shared_ptr<rust::Trait>* self) {
    delete self;
}

} // extern "C"

int32_t _ffi_Box_Trait::get() {
    return _ffi_Box_Trait__get(_self);
}

int32_t _ffi_Rc_Trait::get() {
    return _ffi_Rc_Trait__get(_self);
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}

std::vector<rust::Example> rust::test(std::vector<rust::Example> vec) {
    std::vector<uint8_t> buf;
    auto vec_len = vec.size();
    _ffi_vec_Example_to_rust(std::move(vec), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_test(buf_ptr, vec_len);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_len = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret = _ffi_vec_Example_from_rust(ret_len, buf_end2);
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}
