// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_Box_Trait__get(_self: *const u8) -> i32 {
    let _self = unsafe { &*(_self as *const Box<dyn Trait>) };
    _self.get()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_Rc_Trait__get(_self: *const u8) -> i32 {
    let _self = unsafe { &*(_self as *const std::rc::Rc<dyn Trait>) };
    _self.get()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_drop_Box_Trait(ptr: *const u8) {
    drop(unsafe { Box::from_raw(ptr as *mut Box<dyn Trait>) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_drop_Rc_Trait(ptr: *const u8) {
    drop(unsafe { Box::from_raw(ptr as *mut std::rc::Rc<dyn Trait>) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_test(buf_ptr: *const u8, vec_len: usize) -> _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let ret = test(_ffi_vec_Example_from_cpp(vec_len, &mut buf_end));
    let mut buf2 = Vec::<u8>::new();
    let ret_len = ret.len();
    _ffi_vec_Example_to_cpp(ret, &mut buf2);
    _ffi_buf_from_host(buf_ptr, buf_end);
    let (buf_ptr2, buf_cap) = _ffi_buf_to_host(buf2);
    _ffi_ret_ptr_2_usize(buf_ptr2, buf_cap, ret_len)
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);

#[allow(non_camel_case_types)]
struct _ffi_rs_Box_Trait(*const u8);

impl Drop for _ffi_rs_Box_Trait {
    fn drop(&mut self) {
        unsafe extern "C" { fn _ffi_cpp_drop_Box_Trait(_: *const u8); }
        unsafe { _ffi_cpp_drop_Box_Trait(self.0) };
    }
}

impl Trait for _ffi_rs_Box_Trait {
    fn get(&self) -> i32 {
        unsafe extern "C" { fn _ffi_cpp_Box_Trait__get(_: *const u8) -> i32; }
        unsafe { _ffi_cpp_Box_Trait__get(self.0) }
    }
}

#[allow(non_camel_case_types)]
struct _ffi_rs_Rc_Trait(*const u8);

impl Drop for _ffi_rs_Rc_Trait {
    fn drop(&mut self) {
        unsafe extern "C" { fn _ffi_cpp_drop_Rc_Trait(_: *const u8); }
        unsafe { _ffi_cpp_drop_Rc_Trait(self.0) };
    }
}

impl Trait for _ffi_rs_Rc_Trait {
    fn get(&self) -> i32 {
        unsafe extern "C" { fn _ffi_cpp_Rc_Trait__get(_: *const u8) -> i32; }
        unsafe { _ffi_cpp_Rc_Trait__get(self.0) }
    }
}

fn _ffi_string_from_host(ptr: *const u8, len: usize) -> String {
    unsafe { String::from_raw_parts(ptr as *mut u8, len, len) }
}

fn _ffi_string_to_host(buf: String) -> (*const u8, usize, usize) {
    let buf = std::mem::ManuallyDrop::new(buf.into_bytes());
    (buf.as_ptr(), buf.len(), buf.capacity())
}

#[allow(non_snake_case)]
fn _ffi_vec_Example_from_cpp(len: usize, end: &mut *const u8) -> Vec<Example> {
    let mut items = Vec::<Example>::with_capacity(len);
    for _ in 0..len {
        items.push(Example {
            box_ptr: Box::new(_ffi_rs_Box_Trait(_ffi_read::<*const u8>(end))),
            rc_ptr: std::rc::Rc::new(_ffi_rs_Rc_Trait(_ffi_read::<*const u8>(end))),
            text: _ffi_string_from_host(_ffi_read::<*const u8>(end), _ffi_read::<usize>(end)),
            vec_box: _ffi_vec_box_dyn_Trait_from_cpp(_ffi_read::<usize>(end), end),
            vec_rc: _ffi_vec_rc_dyn_Trait_from_cpp(_ffi_read::<usize>(end), end)
        });
    }
    items
}

#[allow(non_snake_case)]
fn _ffi_vec_Example_to_cpp(items: Vec<Example>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(Box::into_raw(Box::new(item.box_ptr)) as *const u8, buf);
        _ffi_write(Box::into_raw(Box::new(item.rc_ptr)) as *const u8, buf);
        let (item_text_ptr, item_text_len, item_text_cap) = _ffi_string_to_host(item.text);
        _ffi_write(item_text_ptr, buf);
        _ffi_write(item_text_len, buf);
        _ffi_write(item_text_cap, buf);
        _ffi_write(item.vec_box.len(), buf);
        _ffi_vec_box_dyn_Trait_to_cpp(item.vec_box, buf);
        _ffi_write(item.vec_rc.len(), buf);
        _ffi_vec_rc_dyn_Trait_to_cpp(item.vec_rc, buf);
    }
}

#[allow(non_snake_case)]
fn _ffi_vec_box_dyn_Trait_from_cpp(len: usize, end: &mut *const u8) -> Vec<Box<dyn Trait>> {
    let mut items = Vec::<Box<dyn Trait>>::with_capacity(len);
    for _ in 0..len {
        items.push(Box::new(_ffi_rs_Box_Trait(_ffi_read::<*const u8>(end))));
    }
    items
}

#[allow(non_snake_case)]
fn _ffi_vec_box_dyn_Trait_to_cpp(items: Vec<Box<dyn Trait>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(Box::into_raw(Box::new(item)) as *const u8, buf);
    }
}

#[allow(non_snake_case)]
fn _ffi_vec_rc_dyn_Trait_from_cpp(len: usize, end: &mut *const u8) -> Vec<std::rc::Rc<dyn Trait>> {
    let mut items = Vec::<std::rc::Rc<dyn Trait>>::with_capacity(len);
    for _ in 0..len {
        items.push(std::rc::Rc::new(_ffi_rs_Rc_Trait(_ffi_read::<*const u8>(end))));
    }
    items
}

#[allow(non_snake_case)]
fn _ffi_vec_rc_dyn_Trait_to_cpp(items: Vec<std::rc::Rc<dyn Trait>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(Box::into_raw(Box::new(item)) as *const u8, buf);
    }
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = &raw const val as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}
