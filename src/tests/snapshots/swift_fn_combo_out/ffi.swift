// This file was generated by miniffi v0.1.0. Do not edit.

struct Foo : Equatable {
    var x: (Bar, [Bar])
    var y: [((), Int32, (Float32, Bool))]

    static func == (a: Foo, b: Foo) -> Bool {
        return (
            a.x.0 == b.x.0 &&
            a.x.1 == b.x.1 &&
            a.y.elementsEqual(b.y, by: { a, b in a.1 == b.1 && a.2.0 == b.2.0 && a.2.1 == b.2.1 })
        )
    }
}

struct Bar : Equatable {
    var x: Int32
    var y: [Foo]
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func check_combo1() -> Foo {
    let multi_ret = _ffi_fn_check_combo1()
    let ret_x_0_x = multi_ret._0
    let buf_ptr = multi_ret._1
    let buf_cap = multi_ret._2
    let ret_x_0_y_len = multi_ret._3
    let ret_x_1_len = multi_ret._4
    let ret_y_len = multi_ret._5
    var buf_end = buf_ptr!
    let ret = Foo(
        x: (
            Bar(x: ret_x_0_x, y: _ffi_vec_Foo_from_rust(Int(ret_x_0_y_len), &buf_end)),
            _ffi_vec_Bar_from_rust(Int(ret_x_1_len), &buf_end)
        ),
        y: _ffi_vec__i32_f32_bool_from_rust(Int(ret_y_len), &buf_end)
    )
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

func check_combo2() -> Foo {
    let multi_ret = _ffi_fn_check_combo2()
    let ret_x_0_x = multi_ret._0
    let buf_ptr = multi_ret._1
    let buf_cap = multi_ret._2
    let ret_x_0_y_len = multi_ret._3
    let ret_x_1_len = multi_ret._4
    let ret_y_len = multi_ret._5
    var buf_end = buf_ptr!
    let ret = Foo(
        x: (
            Bar(x: ret_x_0_x, y: _ffi_vec_Foo_from_rust(Int(ret_x_0_y_len), &buf_end)),
            _ffi_vec_Bar_from_rust(Int(ret_x_1_len), &buf_end)
        ),
        y: _ffi_vec__i32_f32_bool_from_rust(Int(ret_y_len), &buf_end)
    )
    _ffi_dealloc(buf_ptr, buf_cap)
    return ret
}

private func _ffi_read<T>(_ ptr: inout UnsafeRawPointer) -> T {
    let val = ptr.loadUnaligned(fromByteOffset: 0, as: T.self)
    ptr = ptr.advanced(by: MemoryLayout<T>.size)
    return val
}

private func _ffi_vec_Bar_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Bar] {
    var items: [Bar] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(Bar(x: _ffi_read(&end) as Int32, y: _ffi_vec_Foo_from_rust(Int(_ffi_read(&end) as UInt), &end)))
    }
    return items
}

private func _ffi_vec_Foo_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [Foo] {
    var items: [Foo] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(Foo(
            x: (
                Bar(x: _ffi_read(&end) as Int32, y: _ffi_vec_Foo_from_rust(Int(_ffi_read(&end) as UInt), &end)),
                _ffi_vec_Bar_from_rust(Int(_ffi_read(&end) as UInt), &end)
            ),
            y: _ffi_vec__i32_f32_bool_from_rust(Int(_ffi_read(&end) as UInt), &end)
        ))
    }
    return items
}

private func _ffi_vec__i32_f32_bool_from_rust(_ len: Int, _ end: inout UnsafeRawPointer) -> [((), Int32, (Float32, Bool))] {
    var items: [((), Int32, (Float32, Bool))] = []
    items.reserveCapacity(len)
    while items.count < len {
        items.append(((), _ffi_read(&end) as Int32, (_ffi_read(&end) as Float32, _ffi_read(&end) as Bool)))
    }
    return items
}
