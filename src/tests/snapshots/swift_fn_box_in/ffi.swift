// This file was generated by miniffi v0.1.0. Do not edit.

class Tree : Equatable {
    var value: Int32
    var left: Tree?
    var right: Tree?

    init(value: Int32, left: Tree?, right: Tree?) {
        self.value = value
        self.left = left
        self.right = right
    }

    static func == (a: Tree, b: Tree) -> Bool {
        return a.value == b.value && a.left == b.left && a.right == b.right
    }
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func sum_tree(_ tree: Tree) -> Int32 {
    var buf = ContiguousArray<UInt8>()
    let has_tree_left = tree.left != nil
    if let tree_left_val = tree.left {
        _ffi_box_Tree_to_rust(tree_left_val, &buf)
    }
    let has_tree_right = tree.right != nil
    if let tree_right_val = tree.right {
        _ffi_box_Tree_to_rust(tree_right_val, &buf)
    }
    return _ffi_fn_sum_tree(tree.value, _ffi_vec_to_rust(buf), has_tree_left, has_tree_right)
}

func check_nested(_ x: Int32) -> Int32 {
    var buf = ContiguousArray<UInt8>()
    _ffi_box_box_box_i32_to_rust(x, &buf)
    return _ffi_fn_check_nested(_ffi_vec_to_rust(buf))
}

private func _ffi_box_Tree_to_rust(_ val: Tree, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val.value, &buf)
    _ffi_write(val.left != nil, &buf)
    if let val_left_val = val.left {
        _ffi_box_Tree_to_rust(val_left_val, &buf)
    }
    _ffi_write(val.right != nil, &buf)
    if let val_right_val = val.right {
        _ffi_box_Tree_to_rust(val_right_val, &buf)
    }
}

private func _ffi_box_box_box_i32_to_rust(_ val: Int32, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_box_box_i32_to_rust(val, &buf)
}

private func _ffi_box_box_i32_to_rust(_ val: Int32, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_box_i32_to_rust(val, &buf)
}

private func _ffi_box_i32_to_rust(_ val: Int32, _ buf: inout ContiguousArray<UInt8>) {
    _ffi_write(val, &buf)
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
