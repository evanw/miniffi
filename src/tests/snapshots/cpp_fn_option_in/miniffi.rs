// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw(Box::<[u8]>::new_uninit_slice(len)) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_add_all(buf_ptr: *const u8, x_len: usize) -> i32 {
    let mut buf_end = buf_ptr;
    let ret = add_all(_ffi_vec_option_i32_from_cpp(x_len, &mut buf_end));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_add_nested(buf_ptr: *const u8, has_x: bool, has_y: bool) -> i32 {
    let mut buf_end = buf_ptr;
    let ret = add_nested(
        has_x.then(|| _ffi_read::<bool>(&mut buf_end).then(|| _ffi_read::<i32>(&mut buf_end))),
        has_y.then(|| _ffi_read::<bool>(&mut buf_end).then(|| _ffi_read::<i32>(&mut buf_end)))
    );
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_add_option(buf_ptr: *const u8, has_x: bool, has_y: bool) -> i32 {
    let mut buf_end = buf_ptr;
    let ret = add_option(has_x.then(|| _ffi_read::<i32>(&mut buf_end)), has_y.then(|| _ffi_read::<i32>(&mut buf_end)));
    _ffi_buf_from_host(buf_ptr, buf_end);
    ret
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_join_all(buf_ptr: *const u8, x_len: usize) -> _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let (ret_ptr, ret_len, ret_cap) = _ffi_string_to_host(join_all(_ffi_vec_option_string_from_cpp(x_len, &mut buf_end)));
    _ffi_buf_from_host(buf_ptr, buf_end);
    _ffi_ret_ptr_2_usize(ret_ptr, ret_len, ret_cap)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(size_of::<T>() as isize) };
    val
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);

fn _ffi_string_from_host(ptr: *const u8, len: usize) -> String {
    unsafe { String::from_raw_parts(ptr as *mut u8, len, len) }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_string_to_host(buf: String) -> (*const u8, usize, usize) {
    let buf = std::mem::ManuallyDrop::new(buf.into_bytes());
    (buf.as_ptr(), buf.len(), buf.capacity())
}

fn _ffi_vec_option_i32_from_cpp(len: usize, end: &mut *const u8) -> Vec<Option<i32>> {
    let mut items = Vec::<Option<i32>>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<bool>(end).then(|| _ffi_read::<i32>(end)));
    }
    items
}

fn _ffi_vec_option_string_from_cpp(len: usize, end: &mut *const u8) -> Vec<Option<String>> {
    let mut items = Vec::<Option<String>>::with_capacity(len);
    for _ in 0..len {
        items.push(_ffi_read::<bool>(end).then(|| _ffi_string_from_host(_ffi_read::<*const u8>(end), _ffi_read::<usize>(end))));
    }
    items
}
