// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_ptr_2_usize {
    const char* _0;
    uintptr_t _1;
    uintptr_t _2;
};

extern "C" {

void* _ffi_alloc(uintptr_t len);
int32_t _ffi_fn_add_all(const void* buf_ptr, uintptr_t x_len);
int32_t _ffi_fn_add_nested(const void* buf_ptr, bool has_x, bool has_y);
int32_t _ffi_fn_add_option(const void* buf_ptr, bool has_x, bool has_y);
_ffi_ret_ptr_2_usize _ffi_fn_join_all(const void* buf_ptr, uintptr_t x_len);
void _ffi_dealloc(const void* ptr, uintptr_t capacity);
uintptr_t _ffi_fn_rust_mem_leaked();

} // extern "C"

namespace {

const void* _ffi_string_to_rust(const std::string& str, uintptr_t &len) {
    len = str.size();
    return memcpy(_ffi_alloc(len), str.data(), len);
}

template <typename T>
void _ffi_write(T val, std::vector<uint8_t> &buf) {
    buf.insert(buf.end(), (const uint8_t*)&val, (const uint8_t*)&val + sizeof(T));
}

void _ffi_vec_option_i32_to_rust(std::vector<std::optional<int32_t>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        auto has_item = item.has_value();
        _ffi_write(has_item, buf);
        if (has_item) {
            _ffi_write(item.value(), buf);
        }
    }
}

const void* _ffi_vec_to_rust(const std::vector<uint8_t>& vec) {
    return memcpy(_ffi_alloc(vec.size()), vec.data(), vec.size());
}

std::string _ffi_string_from_rust(const char* ptr, uintptr_t len, uintptr_t cap) {
    std::string str(ptr, len);
    _ffi_dealloc(ptr, cap);
    return str;
}

void _ffi_vec_option_string_to_rust(std::vector<std::optional<std::string>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        auto has_item = item.has_value();
        _ffi_write(has_item, buf);
        if (has_item) {
            uintptr_t item_val_len;
            const void* item_val_ptr = _ffi_string_to_rust(item.value(), item_val_len);
            _ffi_write(item_val_ptr, buf);
            _ffi_write(item_val_len, buf);
        }
    }
}

} // namespace

int32_t rust::add_all(std::vector<std::optional<int32_t>> x) {
    std::vector<uint8_t> buf;
    auto x_len = x.size();
    _ffi_vec_option_i32_to_rust(std::move(x), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    return _ffi_fn_add_all(buf_ptr, x_len);
}

int32_t rust::add_nested(std::optional<std::optional<int32_t>> x, std::optional<std::optional<int32_t>> y) {
    std::vector<uint8_t> buf;
    auto has_x = x.has_value();
    if (has_x) {
        auto has_x_val = x.value().has_value();
        _ffi_write(has_x_val, buf);
        if (has_x_val) {
            _ffi_write(x.value().value(), buf);
        }
    }
    auto has_y = y.has_value();
    if (has_y) {
        auto has_y_val = y.value().has_value();
        _ffi_write(has_y_val, buf);
        if (has_y_val) {
            _ffi_write(y.value().value(), buf);
        }
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    return _ffi_fn_add_nested(buf_ptr, has_x, has_y);
}

int32_t rust::add_option(std::optional<int32_t> x, std::optional<int32_t> y) {
    std::vector<uint8_t> buf;
    auto has_x = x.has_value();
    if (has_x) {
        _ffi_write(x.value(), buf);
    }
    auto has_y = y.has_value();
    if (has_y) {
        _ffi_write(y.value(), buf);
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    return _ffi_fn_add_option(buf_ptr, has_x, has_y);
}

std::string rust::join_all(std::vector<std::optional<std::string>> x) {
    std::vector<uint8_t> buf;
    auto x_len = x.size();
    _ffi_vec_option_string_to_rust(std::move(x), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_join_all(buf_ptr, x_len);
    auto ret_ptr = multi_ret._0;
    auto ret_len = multi_ret._1;
    auto ret_cap = multi_ret._2;
    return _ffi_string_from_rust(ret_ptr, ret_len, ret_cap);
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}
