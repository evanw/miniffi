// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_int(x: bool, y: i32) -> *const _ffi_ret_ptr_usize_bool {
    let ret = opt_int(x, y);
    let mut buf = Vec::<u8>::new();
    let has_ret = ret.is_some();
    if let Some(ret_val) = ret {
        _ffi_write(ret_val, &mut buf);
    }
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    unsafe {
        _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr, buf_cap, has_ret);
        std::ptr::addr_of!(_FFI_RET_PTR_USIZE_BOOL)
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_opt_int(x: bool, y: bool, z: i32) -> *const _ffi_ret_ptr_usize_bool {
    let ret = opt_opt_int(x, y, z);
    let mut buf = Vec::<u8>::new();
    let has_ret = ret.is_some();
    if let Some(ret_val) = ret {
        _ffi_write(ret_val.is_some(), &mut buf);
        if let Some(ret_val_val) = ret_val {
            _ffi_write(ret_val_val, &mut buf);
        }
    }
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    unsafe {
        _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr, buf_cap, has_ret);
        std::ptr::addr_of!(_FFI_RET_PTR_USIZE_BOOL)
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_opt_vec_opt_string(n: i32) -> *const _ffi_ret_ptr_usize_bool {
    let ret = opt_vec_opt_string(n);
    let mut buf = Vec::<u8>::new();
    let has_ret = ret.is_some();
    if let Some(ret_val) = ret {
        _ffi_write(ret_val.len(), &mut buf);
        _ffi_vec_option_string_to_js(ret_val, &mut buf);
    }
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    unsafe {
        _FFI_RET_PTR_USIZE_BOOL = _ffi_ret_ptr_usize_bool(buf_ptr, buf_cap, has_ret);
        std::ptr::addr_of!(_FFI_RET_PTR_USIZE_BOOL)
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_vec_opt_int(n: i32) -> *const _ffi_ret_ptr_2_usize {
    let ret = vec_opt_int(n);
    let mut buf = Vec::<u8>::new();
    let ret_len = ret.len();
    _ffi_vec_option_i32_to_js(ret, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    unsafe {
        _FFI_RET_PTR_2_USIZE = _ffi_ret_ptr_2_usize(buf_ptr, buf_cap, ret_len);
        std::ptr::addr_of!(_FFI_RET_PTR_2_USIZE)
    }
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);
static mut _FFI_RET_PTR_2_USIZE: _ffi_ret_ptr_2_usize = _ffi_ret_ptr_2_usize(std::ptr::null(), 0, 0);

#[repr(C)]
struct _ffi_ret_ptr_usize_bool(*const u8, usize, bool);
static mut _FFI_RET_PTR_USIZE_BOOL: _ffi_ret_ptr_usize_bool = _ffi_ret_ptr_usize_bool(std::ptr::null(), 0, false);

fn _ffi_string_to_host(buf: String) -> (*const u8, usize, usize) {
    let buf = std::mem::ManuallyDrop::new(buf.into_bytes());
    (buf.as_ptr(), buf.len(), buf.capacity())
}

fn _ffi_vec_option_i32_to_js(items: Vec<Option<i32>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.is_some(), buf);
        if let Some(item_val) = item {
            _ffi_write(item_val, buf);
        }
    }
}

fn _ffi_vec_option_string_to_js(items: Vec<Option<String>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.is_some(), buf);
        if let Some(item_val) = item {
            let (item_val_ptr, item_val_len, item_val_cap) = _ffi_string_to_host(item_val);
            _ffi_write(item_val_ptr, buf);
            _ffi_write(item_val_len, buf);
            _ffi_write(item_val_cap, buf);
        }
    }
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = std::ptr::addr_of!(val) as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}
