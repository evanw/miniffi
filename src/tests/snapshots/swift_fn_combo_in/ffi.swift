// This file was generated by miniffi v0.1.0. Do not edit.

struct Foo {
    var x: (Bar, [Bar])
    var y: [((), Int32, (Float32, Bool))]
}

struct Bar {
    var x: Int32
    var y: [Foo]
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func check_combo(_ foo: Foo) -> String {
    var buf = ContiguousArray<UInt8>()
    let foo_x_0_y_len = UInt(foo.x.0.y.count)
    _ffi_vec_Foo_to_rust(foo.x.0.y, &buf)
    let foo_x_1_len = UInt(foo.x.1.count)
    _ffi_vec_Bar_to_rust(foo.x.1, &buf)
    let foo_y_len = UInt(foo.y.count)
    _ffi_vec__i32_f32_bool_to_rust(foo.y, &buf)
    let multi_ret = _ffi_fn_check_combo(foo.x.0.x, _ffi_vec_to_rust(buf), foo_x_0_y_len, foo_x_1_len, foo_y_len)
    let ret_ptr = multi_ret._0
    let ret_len = multi_ret._1
    let ret_cap = multi_ret._2
    return _ffi_string_from_rust(ret_ptr, Int(ret_len), ret_cap)
}

private func _ffi_string_from_rust(_ ptr: UnsafeRawPointer?, _ len: Int, _ cap: UInt) -> String {
    let buf = UnsafeBufferPointer(start: ptr!.assumingMemoryBound(to: UInt8.self), count: len)
    let str = String(decoding: buf, as: UTF8.self)
    _ffi_dealloc(ptr, cap)
    return str
}

private func _ffi_vec_Bar_to_rust(_ items: [Bar], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item.x, &buf)
        _ffi_write(UInt(item.y.count), &buf)
        _ffi_vec_Foo_to_rust(item.y, &buf)
    }
}

private func _ffi_vec_Foo_to_rust(_ items: [Foo], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item.x.0.x, &buf)
        _ffi_write(UInt(item.x.0.y.count), &buf)
        _ffi_vec_Foo_to_rust(item.x.0.y, &buf)
        _ffi_write(UInt(item.x.1.count), &buf)
        _ffi_vec_Bar_to_rust(item.x.1, &buf)
        _ffi_write(UInt(item.y.count), &buf)
        _ffi_vec__i32_f32_bool_to_rust(item.y, &buf)
    }
}

private func _ffi_vec__i32_f32_bool_to_rust(_ items: [((), Int32, (Float32, Bool))], _ buf: inout ContiguousArray<UInt8>) {
    for item in items {
        _ffi_write(item.1, &buf)
        _ffi_write(item.2.0, &buf)
        _ffi_write(item.2.1, &buf)
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
