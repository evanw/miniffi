// This file was generated by miniffi v0.1.0. Do not edit.

#pragma once

#include <stdint.h>
#include <variant>
#include <memory>
#include <tuple>
#include <optional>
#include <vector>

namespace rust {

struct InnerEnum;
struct InnerStruct;
struct NestedBox;
struct NestedOption;
struct NestedTuple;
struct NestedVec;

namespace detail {

struct NestedEnum__Foo {
};

struct NestedEnum__Bar {
    std::tuple<int32_t, std::unique_ptr<InnerEnum>> _0;
};

} // namespace detail

struct NestedEnum : std::variant<std::monostate, detail::NestedEnum__Foo, detail::NestedEnum__Bar> {
    using Foo = detail::NestedEnum__Foo;
    using Bar = detail::NestedEnum__Bar;
    using std::variant<std::monostate, Foo, Bar>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct InnerEnum__Foo {
    NestedEnum _0;
};

} // namespace detail

struct InnerEnum : std::variant<std::monostate, detail::InnerEnum__Foo> {
    using Foo = detail::InnerEnum__Foo;
    using std::variant<std::monostate, Foo>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct NestedStruct__Foo {
};

struct NestedStruct__Bar {
    std::tuple<int32_t, std::unique_ptr<InnerStruct>> _0;
};

} // namespace detail

struct NestedStruct : std::variant<std::monostate, detail::NestedStruct__Foo, detail::NestedStruct__Bar> {
    using Foo = detail::NestedStruct__Foo;
    using Bar = detail::NestedStruct__Bar;
    using std::variant<std::monostate, Foo, Bar>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct InnerStruct {
    NestedStruct x;
};

namespace detail {

struct NestedBox__Foo {
};

struct NestedBox__Bar {
    std::unique_ptr<NestedBox> _0;
};

} // namespace detail

struct NestedBox : std::variant<std::monostate, detail::NestedBox__Foo, detail::NestedBox__Bar> {
    using Foo = detail::NestedBox__Foo;
    using Bar = detail::NestedBox__Bar;
    using std::variant<std::monostate, Foo, Bar>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct NestedOption__Foo {
};

struct NestedOption__Bar {
    std::optional<std::unique_ptr<NestedOption>> _0;
};

} // namespace detail

struct NestedOption : std::variant<std::monostate, detail::NestedOption__Foo, detail::NestedOption__Bar> {
    using Foo = detail::NestedOption__Foo;
    using Bar = detail::NestedOption__Bar;
    using std::variant<std::monostate, Foo, Bar>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct NestedTuple__Foo {
};

struct NestedTuple__Bar {
    std::tuple<int32_t, std::unique_ptr<NestedTuple>> _0;
};

} // namespace detail

struct NestedTuple : std::variant<std::monostate, detail::NestedTuple__Foo, detail::NestedTuple__Bar> {
    using Foo = detail::NestedTuple__Foo;
    using Bar = detail::NestedTuple__Bar;
    using std::variant<std::monostate, Foo, Bar>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct NestedVec__Foo {
};

struct NestedVec__Bar {
    std::vector<NestedVec> _0;
};

} // namespace detail

struct NestedVec : std::variant<std::monostate, detail::NestedVec__Foo, detail::NestedVec__Bar> {
    using Foo = detail::NestedVec__Foo;
    using Bar = detail::NestedVec__Bar;
    using std::variant<std::monostate, Foo, Bar>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

uintptr_t rust_mem_leaked();

} // namespace rust
