// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"
#include <stdlib.h>
#include <algorithm>

struct _ffi_ret_ptr_2_usize {
    const void* _0;
    uintptr_t _1;
    uintptr_t _2;
};

struct _ffi_ret_ptr_usize {
    const void* _0;
    uintptr_t _1;
};

struct _ffi_ret_ptr_usize_bool {
    const void* _0;
    uintptr_t _1;
    bool _2;
};

extern "C" {

void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_ptr_usize _ffi_fn_box_opt(const void* buf_ptr);
void* _ffi_alloc(uintptr_t len);
_ffi_ret_ptr_usize _ffi_fn_box_opt_box(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_box_tup_0(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_box_tup_1(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_box_tup_2(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_box_vec(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_box_vec_box(const void* buf_ptr);
void _ffi_fn_empty_struct();
void _ffi_fn_empty_tuple();
_ffi_ret_ptr_usize _ffi_fn_enum_box_tup(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_enum_opt_tup(const void* buf_ptr);
_ffi_ret_ptr_usize _ffi_fn_enum_vec_tup(const void* buf_ptr);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_box(const void* buf_ptr, bool has_x_0);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_box_opt(const void* buf_ptr, bool has_x_0);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_tup_0(const void* buf_ptr, bool has_x_0);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_tup_1(const void* buf_ptr, bool has_x_0);
_ffi_ret_ptr_usize_bool _ffi_fn_opt_tup_2(const void* buf_ptr, bool has_x_0);
uintptr_t _ffi_fn_rust_mem_leaked();
_ffi_ret_ptr_usize _ffi_fn_tup_box(const void* buf_ptr);
_ffi_ret_ptr_2_usize _ffi_fn_vec_box(const void* buf_ptr, uintptr_t x_0_len);
_ffi_ret_ptr_2_usize _ffi_fn_vec_box_vec(const void* buf_ptr, uintptr_t x_0_len);
_ffi_ret_ptr_2_usize _ffi_fn_vec_tup_0(const void* buf_ptr, uintptr_t x_0_len);
_ffi_ret_ptr_2_usize _ffi_fn_vec_tup_1(const void* buf_ptr, uintptr_t x_0_len);
_ffi_ret_ptr_2_usize _ffi_fn_vec_tup_2(const void* buf_ptr, uintptr_t x_0_len);

} // extern "C"

namespace {

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

std::unique_ptr<std::tuple<int32_t, int32_t>> _ffi_box_i32_i32_from_rust(const uint8_t*& end) {
    auto val_0 = _ffi_read<int32_t>(end);
    auto val_1 = _ffi_read<int32_t>(end);
    auto val = std::make_tuple(val_0, val_1);
    return std::make_unique<std::tuple<int32_t, int32_t>>(std::move(val));
}

rust::EnumBoxTup _ffi_enum_EnumBoxTup_from_rust(const uint8_t*& end) {
    switch (_ffi_read<int32_t>(end)) {
    case 0: {
        auto x = _ffi_box_i32_i32_from_rust(end);
        return rust::EnumBoxTup{rust::EnumBoxTup::Foo{std::move(x)}};
    }
    case 1:
        return rust::EnumBoxTup{rust::EnumBoxTup::Bar{}};
    case 2: {
        auto x = _ffi_read<int32_t>(end);
        auto y = _ffi_read<int32_t>(end);
        return rust::EnumBoxTup{rust::EnumBoxTup::Baz{x, y}};
    }
    default:
        abort();
    }
}

template <typename T>
void _ffi_write(T val, std::vector<uint8_t> &buf) {
    buf.insert(buf.end(), (const uint8_t*)&val, (const uint8_t*)&val + sizeof(T));
}

void _ffi_box_i32_i32_to_rust(std::tuple<int32_t, int32_t> val, std::vector<uint8_t>& buf) {
    _ffi_write(std::get<0>(val), buf);
    _ffi_write(std::get<1>(val), buf);
}

void _ffi_enum_EnumBoxTup_to_rust(rust::EnumBoxTup val, std::vector<uint8_t>& buf) {
    if (auto it = val.as<rust::EnumBoxTup::Foo>()) {
        _ffi_write(int32_t(0), buf);
        _ffi_box_i32_i32_to_rust(std::move(*it->_0), buf);
    } else if (val.is<rust::EnumBoxTup::Bar>()) {
        _ffi_write(int32_t(1), buf);
    } else if (auto it = val.as<rust::EnumBoxTup::Baz>()) {
        _ffi_write(int32_t(2), buf);
        _ffi_write(it->x, buf);
        _ffi_write(it->y, buf);
    } else {
        abort();
    }
}

rust::EnumOptTup _ffi_enum_EnumOptTup_from_rust(const uint8_t*& end) {
    switch (_ffi_read<int32_t>(end)) {
    case 0: {
        std::optional<std::tuple<int32_t, int32_t>> x;
        if (_ffi_read<bool>(end)) {
            auto x_val_0 = _ffi_read<int32_t>(end);
            auto x_val_1 = _ffi_read<int32_t>(end);
            x = std::make_optional(std::make_tuple(x_val_0, x_val_1));
        }
        return rust::EnumOptTup{rust::EnumOptTup::Foo{std::move(x)}};
    }
    case 1:
        return rust::EnumOptTup{rust::EnumOptTup::Bar{}};
    case 2: {
        auto x = _ffi_read<int32_t>(end);
        auto y = _ffi_read<int32_t>(end);
        return rust::EnumOptTup{rust::EnumOptTup::Baz{x, y}};
    }
    default:
        abort();
    }
}

void _ffi_enum_EnumOptTup_to_rust(rust::EnumOptTup val, std::vector<uint8_t>& buf) {
    if (auto it = val.as<rust::EnumOptTup::Foo>()) {
        _ffi_write(int32_t(0), buf);
        auto has_x = it->_0.has_value();
        _ffi_write(has_x, buf);
        if (has_x) {
            _ffi_write(std::get<0>(it->_0.value()), buf);
            _ffi_write(std::get<1>(it->_0.value()), buf);
        }
    } else if (val.is<rust::EnumOptTup::Bar>()) {
        _ffi_write(int32_t(1), buf);
    } else if (auto it = val.as<rust::EnumOptTup::Baz>()) {
        _ffi_write(int32_t(2), buf);
        _ffi_write(it->x, buf);
        _ffi_write(it->y, buf);
    } else {
        abort();
    }
}

std::vector<std::tuple<int32_t, int32_t>> _ffi_vec_i32_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::tuple<int32_t, int32_t>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_0 = _ffi_read<int32_t>(end);
        auto item_1 = _ffi_read<int32_t>(end);
        auto item = std::make_tuple(item_0, item_1);
        items.emplace_back(std::move(item));
    }
    return items;
}

rust::EnumVecTup _ffi_enum_EnumVecTup_from_rust(const uint8_t*& end) {
    switch (_ffi_read<int32_t>(end)) {
    case 0: {
        auto x_len = _ffi_read<uintptr_t>(end);
        auto x = _ffi_vec_i32_i32_from_rust(x_len, end);
        return rust::EnumVecTup{rust::EnumVecTup::Foo{std::move(x)}};
    }
    case 1:
        return rust::EnumVecTup{rust::EnumVecTup::Bar{}};
    case 2: {
        auto x = _ffi_read<int32_t>(end);
        auto y = _ffi_read<int32_t>(end);
        return rust::EnumVecTup{rust::EnumVecTup::Baz{x, y}};
    }
    default:
        abort();
    }
}

void _ffi_vec_i32_i32_to_rust(std::vector<std::tuple<int32_t, int32_t>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_write(std::get<0>(item), buf);
        _ffi_write(std::get<1>(item), buf);
    }
}

void _ffi_enum_EnumVecTup_to_rust(rust::EnumVecTup val, std::vector<uint8_t>& buf) {
    if (auto it = val.as<rust::EnumVecTup::Foo>()) {
        _ffi_write(int32_t(0), buf);
        auto x_len = it->_0.size();
        _ffi_write(x_len, buf);
        _ffi_vec_i32_i32_to_rust(std::move(it->_0), buf);
    } else if (val.is<rust::EnumVecTup::Bar>()) {
        _ffi_write(int32_t(1), buf);
    } else if (auto it = val.as<rust::EnumVecTup::Baz>()) {
        _ffi_write(int32_t(2), buf);
        _ffi_write(it->x, buf);
        _ffi_write(it->y, buf);
    } else {
        abort();
    }
}

std::unique_ptr<std::optional<int32_t>> _ffi_box_option_i32_from_rust(const uint8_t*& end) {
    auto val = _ffi_read<bool>(end) ? std::make_optional(_ffi_read<int32_t>(end)) : std::nullopt;
    return std::make_unique<std::optional<int32_t>>(std::move(val));
}

void _ffi_box_option_i32_to_rust(std::optional<int32_t> val, std::vector<uint8_t>& buf) {
    auto has_val = val.has_value();
    _ffi_write(has_val, buf);
    if (has_val) {
        _ffi_write(val.value(), buf);
    }
}

const void* _ffi_vec_to_rust(const std::vector<uint8_t>& vec) {
    return memcpy(_ffi_alloc(vec.size()), vec.data(), vec.size());
}

std::unique_ptr<int32_t> _ffi_box_i32_from_rust2(const uint8_t*& end) {
    auto val = _ffi_read<int32_t>(end);
    return std::make_unique<int32_t>(val);
}

std::unique_ptr<std::optional<std::unique_ptr<int32_t>>> _ffi_box_option_box_i32_from_rust(const uint8_t*& end) {
    auto val = _ffi_read<bool>(end) ? std::make_optional(_ffi_box_i32_from_rust2(end)) : std::nullopt;
    return std::make_unique<std::optional<std::unique_ptr<int32_t>>>(std::move(val));
}

void _ffi_box_i32_to_rust2(int32_t val, std::vector<uint8_t>& buf) {
    _ffi_write(val, buf);
}

void _ffi_box_option_box_i32_to_rust(std::optional<std::unique_ptr<int32_t>> val, std::vector<uint8_t>& buf) {
    auto has_val = val.has_value();
    _ffi_write(has_val, buf);
    if (has_val) {
        _ffi_box_i32_to_rust2(std::move(*val.value()), buf);
    }
}

std::unique_ptr<std::tuple<>> _ffi_box__from_rust(const uint8_t*& end) {
    auto val = std::tuple<>();
    return std::make_unique<std::tuple<>>(std::move(val));
}

void _ffi_box__to_rust(std::tuple<> val, std::vector<uint8_t>& buf) {
    (void)val;
}

std::unique_ptr<std::tuple<int32_t>> _ffi_box_i32_from_rust(const uint8_t*& end) {
    auto val_0 = _ffi_read<int32_t>(end);
    auto val = val_0;
    return std::make_unique<std::tuple<int32_t>>(std::move(val));
}

void _ffi_box_i32_to_rust(std::tuple<int32_t> val, std::vector<uint8_t>& buf) {
    _ffi_write(std::get<0>(val), buf);
}

std::vector<int32_t> _ffi_vec_i32_from_rust2(uintptr_t len, const uint8_t*& end) {
    std::vector<int32_t> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = _ffi_read<int32_t>(end);
        items.emplace_back(item);
    }
    return items;
}

std::unique_ptr<std::vector<int32_t>> _ffi_box_vec_i32_from_rust(const uint8_t*& end) {
    auto val_len = _ffi_read<uintptr_t>(end);
    auto val = _ffi_vec_i32_from_rust2(val_len, end);
    return std::make_unique<std::vector<int32_t>>(std::move(val));
}

void _ffi_vec_i32_to_rust2(std::vector<int32_t>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_write(item, buf);
    }
}

void _ffi_box_vec_i32_to_rust(std::vector<int32_t> val, std::vector<uint8_t>& buf) {
    auto val_len = val.size();
    _ffi_write(val_len, buf);
    _ffi_vec_i32_to_rust2(std::move(val), buf);
}

std::vector<std::unique_ptr<int32_t>> _ffi_vec_box_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::unique_ptr<int32_t>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = _ffi_box_i32_from_rust2(end);
        items.emplace_back(std::move(item));
    }
    return items;
}

std::unique_ptr<std::vector<std::unique_ptr<int32_t>>> _ffi_box_vec_box_i32_from_rust(const uint8_t*& end) {
    auto val_len = _ffi_read<uintptr_t>(end);
    auto val = _ffi_vec_box_i32_from_rust(val_len, end);
    return std::make_unique<std::vector<std::unique_ptr<int32_t>>>(std::move(val));
}

void _ffi_vec_box_i32_to_rust(std::vector<std::unique_ptr<int32_t>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_box_i32_to_rust2(std::move(*item), buf);
    }
}

void _ffi_box_vec_box_i32_to_rust(std::vector<std::unique_ptr<int32_t>> val, std::vector<uint8_t>& buf) {
    auto val_len = val.size();
    _ffi_write(val_len, buf);
    _ffi_vec_box_i32_to_rust(std::move(val), buf);
}

std::unique_ptr<bool> _ffi_box_bool_from_rust(const uint8_t*& end) {
    auto val = _ffi_read<bool>(end);
    return std::make_unique<bool>(val);
}

void _ffi_box_bool_to_rust(bool val, std::vector<uint8_t>& buf) {
    _ffi_write(val, buf);
}

std::vector<std::unique_ptr<std::vector<int32_t>>> _ffi_vec_box_vec_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::unique_ptr<std::vector<int32_t>>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = _ffi_box_vec_i32_from_rust(end);
        items.emplace_back(std::move(item));
    }
    return items;
}

void _ffi_vec_box_vec_i32_to_rust(std::vector<std::unique_ptr<std::vector<int32_t>>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_box_vec_i32_to_rust(std::move(*item), buf);
    }
}

std::vector<std::tuple<>> _ffi_vec__from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::tuple<>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = std::tuple<>();
        items.emplace_back(std::move(item));
    }
    return items;
}

void _ffi_vec__to_rust(std::vector<std::tuple<>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        (void)item;
    }
}

std::vector<std::tuple<int32_t>> _ffi_vec_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::tuple<int32_t>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_0 = _ffi_read<int32_t>(end);
        auto item = item_0;
        items.emplace_back(std::move(item));
    }
    return items;
}

void _ffi_vec_i32_to_rust(std::vector<std::tuple<int32_t>>&& items, std::vector<uint8_t>& buf) {
    for (auto&& item : items) {
        _ffi_write(std::get<0>(item), buf);
    }
}

} // namespace

bool rust::BoxOpt::operator == (const rust::BoxOpt& b) const {
    return *_0 == *b._0;
}

bool rust::BoxOptBox::operator == (const rust::BoxOptBox& b) const {
    return (*_0 && *b._0 ? ***_0 == ***b._0 : !*_0 && !*b._0);
}

bool rust::BoxTup0::operator == (const rust::BoxTup0& b) const {
    return *_0 == *b._0;
}

bool rust::BoxTup1::operator == (const rust::BoxTup1& b) const {
    return *_0 == *b._0;
}

bool rust::BoxTup2::operator == (const rust::BoxTup2& b) const {
    return *_0 == *b._0;
}

bool rust::BoxVec::operator == (const rust::BoxVec& b) const {
    return *_0 == *b._0;
}

bool rust::BoxVecBox::operator == (const rust::BoxVecBox& b) const {
    return std::equal((*_0).begin(), (*_0).end(), (*b._0).begin(), (*b._0).end(), [](const auto& a, const auto& b) { return *a == *b; });
}

bool rust::detail::EnumBoxTup__Baz::operator == (const rust::detail::EnumBoxTup__Baz& e) const {
    return x == e.x && y == e.y;
}

bool rust::detail::EnumBoxTup__Foo::operator == (const rust::detail::EnumBoxTup__Foo& e) const {
    return *_0 == *e._0;
}

bool rust::detail::EnumOptTup__Baz::operator == (const rust::detail::EnumOptTup__Baz& e) const {
    return x == e.x && y == e.y;
}

bool rust::detail::EnumOptTup__Foo::operator == (const rust::detail::EnumOptTup__Foo& e) const {
    return _0 == e._0;
}

bool rust::detail::EnumVecTup__Baz::operator == (const rust::detail::EnumVecTup__Baz& e) const {
    return x == e.x && y == e.y;
}

bool rust::detail::EnumVecTup__Foo::operator == (const rust::detail::EnumVecTup__Foo& e) const {
    return _0 == e._0;
}

bool rust::OptBox::operator == (const rust::OptBox& o) const {
    return (_0 && o._0 ? **_0 == **o._0 : !_0 && !o._0);
}

bool rust::OptBoxOpt::operator == (const rust::OptBoxOpt& o) const {
    return (_0 && o._0 ? **_0 == **o._0 : !_0 && !o._0);
}

bool rust::OptTup0::operator == (const rust::OptTup0& o) const {
    return _0 == o._0;
}

bool rust::OptTup1::operator == (const rust::OptTup1& o) const {
    return _0 == o._0;
}

bool rust::OptTup2::operator == (const rust::OptTup2& o) const {
    return _0 == o._0;
}

bool rust::TupBox::operator == (const rust::TupBox& t) const {
    return *std::get<0>(_0) == *std::get<0>(t._0) && *std::get<1>(_0) == *std::get<1>(t._0);
}

bool rust::VecBox::operator == (const rust::VecBox& v) const {
    return std::equal(_0.begin(), _0.end(), v._0.begin(), v._0.end(), [](const auto& a, const auto& b) { return *a == *b; });
}

bool rust::VecBoxVec::operator == (const rust::VecBoxVec& v) const {
    return std::equal(_0.begin(), _0.end(), v._0.begin(), v._0.end(), [](const auto& a, const auto& b) { return *a == *b; });
}

bool rust::VecTup0::operator == (const rust::VecTup0& v) const {
    return _0 == v._0;
}

bool rust::VecTup1::operator == (const rust::VecTup1& v) const {
    return _0 == v._0;
}

bool rust::VecTup2::operator == (const rust::VecTup2& v) const {
    return _0 == v._0;
}

rust::BoxOpt rust::box_opt(rust::BoxOpt x) {
    std::vector<uint8_t> buf;
    _ffi_box_option_i32_to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_opt(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box_option_i32_from_rust(buf_end2);
    auto ret = rust::BoxOpt{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::BoxOptBox rust::box_opt_box(rust::BoxOptBox x) {
    std::vector<uint8_t> buf;
    _ffi_box_option_box_i32_to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_opt_box(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box_option_box_i32_from_rust(buf_end2);
    auto ret = rust::BoxOptBox{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::BoxTup0 rust::box_tup_0(rust::BoxTup0 x) {
    std::vector<uint8_t> buf;
    _ffi_box__to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_tup_0(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box__from_rust(buf_end2);
    auto ret = rust::BoxTup0{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::BoxTup1 rust::box_tup_1(rust::BoxTup1 x) {
    std::vector<uint8_t> buf;
    _ffi_box_i32_to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_tup_1(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box_i32_from_rust(buf_end2);
    auto ret = rust::BoxTup1{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::BoxTup2 rust::box_tup_2(rust::BoxTup2 x) {
    std::vector<uint8_t> buf;
    _ffi_box_i32_i32_to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_tup_2(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box_i32_i32_from_rust(buf_end2);
    auto ret = rust::BoxTup2{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::BoxVec rust::box_vec(rust::BoxVec x) {
    std::vector<uint8_t> buf;
    _ffi_box_vec_i32_to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_vec(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box_vec_i32_from_rust(buf_end2);
    auto ret = rust::BoxVec{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::BoxVecBox rust::box_vec_box(rust::BoxVecBox x) {
    std::vector<uint8_t> buf;
    _ffi_box_vec_box_i32_to_rust(std::move(*x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_box_vec_box(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_box_vec_box_i32_from_rust(buf_end2);
    auto ret = rust::BoxVecBox{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::EmptyStruct rust::empty_struct(rust::EmptyStruct x) {
    (void)x;
    _ffi_fn_empty_struct();
    return rust::EmptyStruct{};
}

std::tuple<> rust::empty_tuple(std::tuple<> x) {
    (void)x;
    _ffi_fn_empty_tuple();
    return std::tuple<>();
}

rust::EnumBoxTup rust::enum_box_tup(rust::EnumBoxTup x) {
    std::vector<uint8_t> buf;
    _ffi_enum_EnumBoxTup_to_rust(std::move(x), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_enum_box_tup(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret = _ffi_enum_EnumBoxTup_from_rust(buf_end2);
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::EnumOptTup rust::enum_opt_tup(rust::EnumOptTup x) {
    std::vector<uint8_t> buf;
    _ffi_enum_EnumOptTup_to_rust(std::move(x), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_enum_opt_tup(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret = _ffi_enum_EnumOptTup_from_rust(buf_end2);
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::EnumVecTup rust::enum_vec_tup(rust::EnumVecTup x) {
    std::vector<uint8_t> buf;
    _ffi_enum_EnumVecTup_to_rust(std::move(x), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_enum_vec_tup(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret = _ffi_enum_EnumVecTup_from_rust(buf_end2);
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::OptBox rust::opt_box(rust::OptBox x) {
    std::vector<uint8_t> buf;
    auto has_x_0 = x._0.has_value();
    if (has_x_0) {
        _ffi_box_i32_to_rust2(std::move(*x._0.value()), buf);
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_opt_box(buf_ptr, has_x_0);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret_0 = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = has_ret_0 ? std::make_optional(_ffi_box_i32_from_rust2(buf_end2)) : std::nullopt;
    auto ret = rust::OptBox{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::OptBoxOpt rust::opt_box_opt(rust::OptBoxOpt x) {
    std::vector<uint8_t> buf;
    auto has_x_0 = x._0.has_value();
    if (has_x_0) {
        _ffi_box_option_i32_to_rust(std::move(*x._0.value()), buf);
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_opt_box_opt(buf_ptr, has_x_0);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret_0 = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = has_ret_0 ? std::make_optional(_ffi_box_option_i32_from_rust(buf_end2)) : std::nullopt;
    auto ret = rust::OptBoxOpt{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::OptTup0 rust::opt_tup_0(rust::OptTup0 x) {
    std::vector<uint8_t> buf;
    auto has_x_0 = x._0.has_value();
    if (has_x_0) {
        (void)x._0.value();
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_opt_tup_0(buf_ptr, has_x_0);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret_0 = multi_ret._2;
    auto ret_0 = has_ret_0 ? std::make_optional(std::tuple<>()) : std::nullopt;
    auto ret = rust::OptTup0{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::OptTup1 rust::opt_tup_1(rust::OptTup1 x) {
    std::vector<uint8_t> buf;
    auto has_x_0 = x._0.has_value();
    if (has_x_0) {
        _ffi_write(std::get<0>(x._0.value()), buf);
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_opt_tup_1(buf_ptr, has_x_0);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret_0 = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    std::optional<std::tuple<int32_t>> ret_0;
    if (has_ret_0) {
        auto ret_0_val_0 = _ffi_read<int32_t>(buf_end2);
        ret_0 = std::make_optional(ret_0_val_0);
    }
    auto ret = rust::OptTup1{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::OptTup2 rust::opt_tup_2(rust::OptTup2 x) {
    std::vector<uint8_t> buf;
    auto has_x_0 = x._0.has_value();
    if (has_x_0) {
        _ffi_write(std::get<0>(x._0.value()), buf);
        _ffi_write(std::get<1>(x._0.value()), buf);
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_opt_tup_2(buf_ptr, has_x_0);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto has_ret_0 = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    std::optional<std::tuple<int32_t, int32_t>> ret_0;
    if (has_ret_0) {
        auto ret_0_val_0 = _ffi_read<int32_t>(buf_end2);
        auto ret_0_val_1 = _ffi_read<int32_t>(buf_end2);
        ret_0 = std::make_optional(std::make_tuple(ret_0_val_0, ret_0_val_1));
    }
    auto ret = rust::OptTup2{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}

rust::TupBox rust::tup_box(rust::TupBox x) {
    std::vector<uint8_t> buf;
    _ffi_box_i32_to_rust2(std::move(*std::get<0>(x._0)), buf);
    _ffi_box_bool_to_rust(std::move(*std::get<1>(x._0)), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_tup_box(buf_ptr);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0_0 = _ffi_box_i32_from_rust2(buf_end2);
    auto ret_0_1 = _ffi_box_bool_from_rust(buf_end2);
    auto ret_0 = std::make_tuple(std::move(ret_0_0), std::move(ret_0_1));
    auto ret = rust::TupBox{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::VecBox rust::vec_box(rust::VecBox x) {
    std::vector<uint8_t> buf;
    auto x_0_len = x._0.size();
    _ffi_vec_box_i32_to_rust(std::move(x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_vec_box(buf_ptr, x_0_len);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_0_len = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_vec_box_i32_from_rust(ret_0_len, buf_end2);
    auto ret = rust::VecBox{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::VecBoxVec rust::vec_box_vec(rust::VecBoxVec x) {
    std::vector<uint8_t> buf;
    auto x_0_len = x._0.size();
    _ffi_vec_box_vec_i32_to_rust(std::move(x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_vec_box_vec(buf_ptr, x_0_len);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_0_len = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_vec_box_vec_i32_from_rust(ret_0_len, buf_end2);
    auto ret = rust::VecBoxVec{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::VecTup0 rust::vec_tup_0(rust::VecTup0 x) {
    std::vector<uint8_t> buf;
    auto x_0_len = x._0.size();
    _ffi_vec__to_rust(std::move(x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_vec_tup_0(buf_ptr, x_0_len);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_0_len = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_vec__from_rust(ret_0_len, buf_end2);
    auto ret = rust::VecTup0{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::VecTup1 rust::vec_tup_1(rust::VecTup1 x) {
    std::vector<uint8_t> buf;
    auto x_0_len = x._0.size();
    _ffi_vec_i32_to_rust(std::move(x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_vec_tup_1(buf_ptr, x_0_len);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_0_len = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_vec_i32_from_rust(ret_0_len, buf_end2);
    auto ret = rust::VecTup1{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}

rust::VecTup2 rust::vec_tup_2(rust::VecTup2 x) {
    std::vector<uint8_t> buf;
    auto x_0_len = x._0.size();
    _ffi_vec_i32_i32_to_rust(std::move(x._0), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    auto multi_ret = _ffi_fn_vec_tup_2(buf_ptr, x_0_len);
    auto buf_ptr2 = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_0_len = multi_ret._2;
    auto buf_end2 = (const uint8_t*)buf_ptr2;
    auto ret_0 = _ffi_vec_i32_i32_from_rust(ret_0_len, buf_end2);
    auto ret = rust::VecTup2{std::move(ret_0)};
    _ffi_dealloc(buf_ptr2, buf_cap);
    return ret;
}
