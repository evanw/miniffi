// This file was generated by miniffi v0.1.0. Do not edit.

#pragma once

#include <stdint.h>
#include <tuple>
#include <memory>
#include <optional>
#include <vector>
#include <variant>

namespace rust {

struct BoxOpt {
    std::unique_ptr<std::optional<int32_t>> _0;
    bool operator == (const BoxOpt&) const;
    bool operator != (const BoxOpt& b) const { return !(*this == b); }
};

struct BoxOptBox {
    std::unique_ptr<std::optional<std::unique_ptr<int32_t>>> _0;
    bool operator == (const BoxOptBox&) const;
    bool operator != (const BoxOptBox& b) const { return !(*this == b); }
};

struct BoxTup0 {
    std::unique_ptr<std::tuple<>> _0;
    bool operator == (const BoxTup0&) const;
    bool operator != (const BoxTup0& b) const { return !(*this == b); }
};

struct BoxTup1 {
    std::unique_ptr<std::tuple<int32_t>> _0;
    bool operator == (const BoxTup1&) const;
    bool operator != (const BoxTup1& b) const { return !(*this == b); }
};

struct BoxTup2 {
    std::unique_ptr<std::tuple<int32_t, int32_t>> _0;
    bool operator == (const BoxTup2&) const;
    bool operator != (const BoxTup2& b) const { return !(*this == b); }
};

struct BoxVec {
    std::unique_ptr<std::vector<int32_t>> _0;
    bool operator == (const BoxVec&) const;
    bool operator != (const BoxVec& b) const { return !(*this == b); }
};

struct BoxVecBox {
    std::unique_ptr<std::vector<std::unique_ptr<int32_t>>> _0;
    bool operator == (const BoxVecBox&) const;
    bool operator != (const BoxVecBox& b) const { return !(*this == b); }
};

struct EmptyStruct {
    bool operator == (const EmptyStruct&) const { return true; }
    bool operator != (const EmptyStruct& e) const { return !(*this == e); }
};

namespace detail {

struct EnumBoxTup__Foo {
    std::unique_ptr<std::tuple<int32_t, int32_t>> _0;
    bool operator == (const EnumBoxTup__Foo&) const;
    bool operator != (const EnumBoxTup__Foo& e) const { return !(*this == e); }
};

struct EnumBoxTup__Bar {
    bool operator == (const EnumBoxTup__Bar&) const { return true; }
    bool operator != (const EnumBoxTup__Bar& e) const { return !(*this == e); }
};

struct EnumBoxTup__Baz {
    int32_t x = 0;
    int32_t y = 0;
    bool operator == (const EnumBoxTup__Baz&) const;
    bool operator != (const EnumBoxTup__Baz& e) const { return !(*this == e); }
};

} // namespace detail

struct EnumBoxTup : std::variant<std::monostate, detail::EnumBoxTup__Foo, detail::EnumBoxTup__Bar, detail::EnumBoxTup__Baz> {
    using Foo = detail::EnumBoxTup__Foo;
    using Bar = detail::EnumBoxTup__Bar;
    using Baz = detail::EnumBoxTup__Baz;
    using std::variant<std::monostate, Foo, Bar, Baz>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct EnumOptTup__Foo {
    std::optional<std::tuple<int32_t, int32_t>> _0;
    bool operator == (const EnumOptTup__Foo&) const;
    bool operator != (const EnumOptTup__Foo& e) const { return !(*this == e); }
};

struct EnumOptTup__Bar {
    bool operator == (const EnumOptTup__Bar&) const { return true; }
    bool operator != (const EnumOptTup__Bar& e) const { return !(*this == e); }
};

struct EnumOptTup__Baz {
    int32_t x = 0;
    int32_t y = 0;
    bool operator == (const EnumOptTup__Baz&) const;
    bool operator != (const EnumOptTup__Baz& e) const { return !(*this == e); }
};

} // namespace detail

struct EnumOptTup : std::variant<std::monostate, detail::EnumOptTup__Foo, detail::EnumOptTup__Bar, detail::EnumOptTup__Baz> {
    using Foo = detail::EnumOptTup__Foo;
    using Bar = detail::EnumOptTup__Bar;
    using Baz = detail::EnumOptTup__Baz;
    using std::variant<std::monostate, Foo, Bar, Baz>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct EnumVecTup__Foo {
    std::vector<std::tuple<int32_t, int32_t>> _0;
    bool operator == (const EnumVecTup__Foo&) const;
    bool operator != (const EnumVecTup__Foo& e) const { return !(*this == e); }
};

struct EnumVecTup__Bar {
    bool operator == (const EnumVecTup__Bar&) const { return true; }
    bool operator != (const EnumVecTup__Bar& e) const { return !(*this == e); }
};

struct EnumVecTup__Baz {
    int32_t x = 0;
    int32_t y = 0;
    bool operator == (const EnumVecTup__Baz&) const;
    bool operator != (const EnumVecTup__Baz& e) const { return !(*this == e); }
};

} // namespace detail

struct EnumVecTup : std::variant<std::monostate, detail::EnumVecTup__Foo, detail::EnumVecTup__Bar, detail::EnumVecTup__Baz> {
    using Foo = detail::EnumVecTup__Foo;
    using Bar = detail::EnumVecTup__Bar;
    using Baz = detail::EnumVecTup__Baz;
    using std::variant<std::monostate, Foo, Bar, Baz>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct OptBox {
    std::optional<std::unique_ptr<int32_t>> _0;
    bool operator == (const OptBox&) const;
    bool operator != (const OptBox& o) const { return !(*this == o); }
};

struct OptBoxOpt {
    std::optional<std::unique_ptr<std::optional<int32_t>>> _0;
    bool operator == (const OptBoxOpt&) const;
    bool operator != (const OptBoxOpt& o) const { return !(*this == o); }
};

struct OptTup0 {
    std::optional<std::tuple<>> _0;
    bool operator == (const OptTup0&) const;
    bool operator != (const OptTup0& o) const { return !(*this == o); }
};

struct OptTup1 {
    std::optional<std::tuple<int32_t>> _0;
    bool operator == (const OptTup1&) const;
    bool operator != (const OptTup1& o) const { return !(*this == o); }
};

struct OptTup2 {
    std::optional<std::tuple<int32_t, int32_t>> _0;
    bool operator == (const OptTup2&) const;
    bool operator != (const OptTup2& o) const { return !(*this == o); }
};

struct TupBox {
    std::tuple<std::unique_ptr<int32_t>, std::unique_ptr<bool>> _0;
    bool operator == (const TupBox&) const;
    bool operator != (const TupBox& t) const { return !(*this == t); }
};

struct VecBox {
    std::vector<std::unique_ptr<int32_t>> _0;
    bool operator == (const VecBox&) const;
    bool operator != (const VecBox& v) const { return !(*this == v); }
};

struct VecBoxVec {
    std::vector<std::unique_ptr<std::vector<int32_t>>> _0;
    bool operator == (const VecBoxVec&) const;
    bool operator != (const VecBoxVec& v) const { return !(*this == v); }
};

struct VecTup0 {
    std::vector<std::tuple<>> _0;
    bool operator == (const VecTup0&) const;
    bool operator != (const VecTup0& v) const { return !(*this == v); }
};

struct VecTup1 {
    std::vector<std::tuple<int32_t>> _0;
    bool operator == (const VecTup1&) const;
    bool operator != (const VecTup1& v) const { return !(*this == v); }
};

struct VecTup2 {
    std::vector<std::tuple<int32_t, int32_t>> _0;
    bool operator == (const VecTup2&) const;
    bool operator != (const VecTup2& v) const { return !(*this == v); }
};

uintptr_t rust_mem_leaked();

std::tuple<> empty_tuple(std::tuple<> x);

EmptyStruct empty_struct(EmptyStruct x);

BoxTup0 box_tup_0(BoxTup0 x);

BoxTup1 box_tup_1(BoxTup1 x);

BoxTup2 box_tup_2(BoxTup2 x);

VecTup0 vec_tup_0(VecTup0 x);

VecTup1 vec_tup_1(VecTup1 x);

VecTup2 vec_tup_2(VecTup2 x);

OptTup0 opt_tup_0(OptTup0 x);

OptTup1 opt_tup_1(OptTup1 x);

OptTup2 opt_tup_2(OptTup2 x);

EnumBoxTup enum_box_tup(EnumBoxTup x);

EnumVecTup enum_vec_tup(EnumVecTup x);

EnumOptTup enum_opt_tup(EnumOptTup x);

TupBox tup_box(TupBox x);

VecBox vec_box(VecBox x);

BoxVec box_vec(BoxVec x);

OptBox opt_box(OptBox x);

BoxOpt box_opt(BoxOpt x);

VecBoxVec vec_box_vec(VecBoxVec x);

BoxVecBox box_vec_box(BoxVecBox x);

OptBoxOpt opt_box_opt(OptBoxOpt x);

BoxOptBox box_opt_box(BoxOptBox x);

} // namespace rust
