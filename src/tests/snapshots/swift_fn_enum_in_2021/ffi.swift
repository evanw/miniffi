// This file was generated by miniffi v0.1.0. Do not edit.

enum Foo: Int32 {
    case Zero = 0
    case One = 1
    case Hundred = 100
}

enum Big: Int32 {
    case Min = -2147483648
    case Max = 2147483647
}

enum LongEnum {
    case Empty
    case ShortTuple(Int32)
    case ShortStruct(a: Int32)
    case LongTuple(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32)
    case LongStruct(a: Int32, b: Int32, c: Int32, d: Int32, e: Int32, f: Int32)
}

func rust_mem_leaked() -> UInt {
    return _ffi_fn_rust_mem_leaked()
}

func foo_to_i32(_ foo: Foo) -> Int32 {
    return _ffi_fn_foo_to_i32(foo.rawValue)
}

func big_to_i32(_ big: Big) -> Int32 {
    return _ffi_fn_big_to_i32(big.rawValue)
}

func long_in(_ _1: LongEnum) {
    var buf = ContiguousArray<UInt8>()
    _ffi_enum_LongEnum_to_rust(_1, &buf)
    _ffi_fn_long_in(_ffi_vec_to_rust(buf))
}

private func _ffi_enum_LongEnum_to_rust(_ val: LongEnum, _ buf: inout ContiguousArray<UInt8>) {
    switch val {
    case .Empty:
        _ffi_write(0 as Int32, &buf)
    case let .ShortTuple(x):
        _ffi_write(1 as Int32, &buf)
        _ffi_write(x, &buf)
    case let .ShortStruct(a):
        _ffi_write(2 as Int32, &buf)
        _ffi_write(a, &buf)
    case let .LongTuple(x0, x1, x2, x3, x4, x5, x6, x7):
        _ffi_write(3 as Int32, &buf)
        _ffi_write(x0, &buf)
        _ffi_write(x1, &buf)
        _ffi_write(x2, &buf)
        _ffi_write(x3, &buf)
        _ffi_write(x4, &buf)
        _ffi_write(x5, &buf)
        _ffi_write(x6, &buf)
        _ffi_write(x7, &buf)
    case let .LongStruct(a, b, c, d, e, f):
        _ffi_write(4 as Int32, &buf)
        _ffi_write(a, &buf)
        _ffi_write(b, &buf)
        _ffi_write(c, &buf)
        _ffi_write(d, &buf)
        _ffi_write(e, &buf)
        _ffi_write(f, &buf)
    }
}

private func _ffi_vec_to_rust(_ vec: ContiguousArray<UInt8>) -> UnsafeRawPointer? {
    vec.withUnsafeBytes { vec in
        let buf = UnsafeMutableRawBufferPointer(start: _ffi_alloc(vec.count), count: vec.count)
        buf.copyMemory(from: UnsafeRawBufferPointer(start: vec.baseAddress, count: vec.count))
        return UnsafeRawPointer(buf.baseAddress)
    }
}

private func _ffi_write<T>(_ val: T, _ buf: inout ContiguousArray<UInt8>) {
    var val = val
    withUnsafeBytes(of: &val) { val in
        buf.append(contentsOf: val)
    }
}
