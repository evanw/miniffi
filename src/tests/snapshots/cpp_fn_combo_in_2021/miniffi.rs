// This file was generated by miniffi v0.1.0. Do not edit.

#[no_mangle]
extern "C" fn _ffi_alloc(len: usize) -> *const u8 {
    Box::into_raw([0 as u8].repeat(len).into_boxed_slice()) as *const u8
}

fn _ffi_buf_from_host(ptr: *const u8, end: *const u8) {
    let len = unsafe { end.byte_offset_from(ptr) } as usize;
    drop(unsafe { Vec::from_raw_parts(ptr as *mut u8, 0, len) });
}

#[no_mangle]
extern "C" fn _ffi_fn_check_combo(foo_x_0_x: i32, buf_ptr: *const u8, foo_x_0_y_len: usize, foo_x_1_len: usize, foo_y_len: usize) -> _ffi_ret_ptr_2_usize {
    let mut buf_end = buf_ptr;
    let (ret_ptr, ret_len, ret_cap) = _ffi_string_to_host(check_combo(Foo {
        x: (
            Bar { x: foo_x_0_x, y: _ffi_vec_Foo_from_cpp(foo_x_0_y_len, &mut buf_end) },
            _ffi_vec_Bar_from_cpp(foo_x_1_len, &mut buf_end)
        ),
        y: _ffi_vec__i32_f32_bool_from_cpp(foo_y_len, &mut buf_end)
    }));
    _ffi_buf_from_host(buf_ptr, buf_end);
    _ffi_ret_ptr_2_usize(ret_ptr, ret_len, ret_cap)
}

#[no_mangle]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

fn _ffi_read<T: Copy>(ptr: &mut *const u8) -> T {
    let val = unsafe { (*ptr as *const T).read_unaligned() };
    *ptr = unsafe { ptr.byte_offset(std::mem::size_of::<T>() as isize) };
    val
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);

#[no_mangle]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_string_to_host(buf: String) -> (*const u8, usize, usize) {
    let buf = std::mem::ManuallyDrop::new(buf.into_bytes());
    (buf.as_ptr(), buf.len(), buf.capacity())
}

#[allow(non_snake_case)]
fn _ffi_vec_Bar_from_cpp(len: usize, end: &mut *const u8) -> Vec<Bar> {
    let mut items = Vec::<Bar>::with_capacity(len);
    for _ in 0..len {
        items.push(Bar { x: _ffi_read::<i32>(end), y: _ffi_vec_Foo_from_cpp(_ffi_read::<usize>(end), end) });
    }
    items
}

#[allow(non_snake_case)]
fn _ffi_vec_Foo_from_cpp(len: usize, end: &mut *const u8) -> Vec<Foo> {
    let mut items = Vec::<Foo>::with_capacity(len);
    for _ in 0..len {
        items.push(Foo {
            x: (
                Bar { x: _ffi_read::<i32>(end), y: _ffi_vec_Foo_from_cpp(_ffi_read::<usize>(end), end) },
                _ffi_vec_Bar_from_cpp(_ffi_read::<usize>(end), end)
            ),
            y: _ffi_vec__i32_f32_bool_from_cpp(_ffi_read::<usize>(end), end)
        });
    }
    items
}

#[allow(non_snake_case)]
fn _ffi_vec__i32_f32_bool_from_cpp(len: usize, end: &mut *const u8) -> Vec<((), (i32,), (f32, bool))> {
    let mut items = Vec::<((), (i32,), (f32, bool))>::with_capacity(len);
    for _ in 0..len {
        items.push(((), (_ffi_read::<i32>(end),), (_ffi_read::<f32>(end), _ffi_read::<bool>(end))));
    }
    items
}
