// This file was generated by miniffi v0.1.0. Do not edit.

#pragma once

#include <stdint.h>
#include <variant>
#include <vector>
#include <memory>

namespace rust {

struct SecondEnum;
struct SecondStruct;
struct SecondTrait;
struct FirstEnum;
struct FirstStruct;
struct FirstTrait;

namespace detail {

struct EarlyInsideEnum__Value {
    bool _0 = false;
};

} // namespace detail

struct EarlyInsideEnum : std::variant<std::monostate, detail::EarlyInsideEnum__Value> {
    using Value = detail::EarlyInsideEnum__Value;
    using std::variant<std::monostate, Value>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct EarlyInsideStruct {
    bool y = false;
};

namespace detail {

struct LaterInsideEnum__Value {
    bool _0 = false;
};

} // namespace detail

struct LaterInsideEnum : std::variant<std::monostate, detail::LaterInsideEnum__Value> {
    using Value = detail::LaterInsideEnum__Value;
    using std::variant<std::monostate, Value>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

namespace detail {

struct EarlyOutsideEnum__Value {
    LaterInsideEnum _0;
};

} // namespace detail

struct EarlyOutsideEnum : std::variant<std::monostate, detail::EarlyOutsideEnum__Value> {
    using Value = detail::EarlyOutsideEnum__Value;
    using std::variant<std::monostate, Value>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct LaterInsideStruct {
    bool y = false;
};

struct EarlyOutsideStruct {
    LaterInsideStruct x;
};

namespace detail {

struct FirstEnum__Second {
    std::vector<SecondEnum> _0;
};

} // namespace detail

struct FirstEnum : std::variant<std::monostate, detail::FirstEnum__Second> {
    using Second = detail::FirstEnum__Second;
    using std::variant<std::monostate, Second>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct FirstStruct {
    std::vector<SecondStruct> second;
};

struct FirstTrait {
    virtual ~FirstTrait() {}
    virtual std::shared_ptr<SecondTrait> second() = 0;
};

namespace detail {

struct LaterOutsideEnum__Value {
    EarlyInsideEnum _0;
};

} // namespace detail

struct LaterOutsideEnum : std::variant<std::monostate, detail::LaterOutsideEnum__Value> {
    using Value = detail::LaterOutsideEnum__Value;
    using std::variant<std::monostate, Value>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct LaterOutsideStruct {
    EarlyInsideStruct x;
};

namespace detail {

struct SecondEnum__First {
    std::vector<FirstEnum> _0;
};

} // namespace detail

struct SecondEnum : std::variant<std::monostate, detail::SecondEnum__First> {
    using First = detail::SecondEnum__First;
    using std::variant<std::monostate, First>::operator =;
    template <typename T> bool is() const { return std::holds_alternative<T>(*this); }
    template <typename T> const T* as() const { return std::get_if<T>(this); }
    template <typename T> T* as() { return std::get_if<T>(this); }
};

struct SecondStruct {
    std::vector<FirstStruct> first;
};

struct SecondTrait {
    virtual ~SecondTrait() {}
    virtual std::shared_ptr<FirstTrait> first() = 0;
};

uintptr_t rust_mem_leaked();

} // namespace rust
