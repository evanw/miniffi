// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"
#include <stdlib.h>

struct _ffi_ret_ptr_2_usize {
    const void* _0;
    uintptr_t _1;
    uintptr_t _2;
};

extern "C" {

void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_ptr_2_usize _ffi_fn_get_tests();
uintptr_t _ffi_fn_rust_mem_leaked();

} // extern "C"

namespace {

rust::Foo _ffi_enum_Foo_from_rust(const uint8_t*& end);

std::unique_ptr<rust::Foo> _ffi_box_Foo_from_rust(const uint8_t*& end) {
    auto val = _ffi_enum_Foo_from_rust(end);
    return std::make_unique<rust::Foo>(std::move(val));
}

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

rust::Foo _ffi_enum_Foo_from_rust(const uint8_t*& end) {
    switch (_ffi_read<int32_t>(end)) {
    case 0:
        return rust::Foo{rust::Foo::Empty{}};
    case 1: {
        auto x = _ffi_read<int32_t>(end);
        return rust::Foo{rust::Foo::Single{x}};
    }
    case 2: {
        auto x = _ffi_read<int32_t>(end);
        auto y = _ffi_read<int32_t>(end);
        return rust::Foo{rust::Foo::Point{x, y}};
    }
    case 3: {
        auto x = _ffi_box_Foo_from_rust(end);
        return rust::Foo{rust::Foo::Nested{std::move(x)}};
    }
    default:
        abort();
    }
}

std::vector<rust::Foo> _ffi_vec_Foo_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<rust::Foo> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = _ffi_enum_Foo_from_rust(end);
        items.emplace_back(std::move(item));
    }
    return items;
}

} // namespace

bool rust::detail::Foo__Nested::operator == (const rust::detail::Foo__Nested& f) const {
    return *_0 == *f._0;
}

bool rust::detail::Foo__Point::operator == (const rust::detail::Foo__Point& f) const {
    return x == f.x && y == f.y;
}

bool rust::detail::Foo__Single::operator == (const rust::detail::Foo__Single& f) const {
    return _0 == f._0;
}

std::vector<rust::Foo> rust::get_tests() {
    auto multi_ret = _ffi_fn_get_tests();
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_len = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret = _ffi_vec_Foo_from_rust(ret_len, buf_end);
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}
