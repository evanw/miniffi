// This file was generated by miniffi v0.1.0. Do not edit.

#[allow(non_snake_case)]
fn _ffi_box_Foo_to_cpp(val: Foo, buf: &mut Vec<u8>) {
    _ffi_enum_Foo_to_cpp(val, buf);
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = &raw const val as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}

#[allow(non_snake_case)]
fn _ffi_enum_Foo_to_cpp(val: Foo, buf: &mut Vec<u8>) {
    match val {
        Foo::Empty => _ffi_write(0 as i32, buf),
        Foo::Single(x) => {
            _ffi_write(1 as i32, buf);
            _ffi_write(x, buf);
        }
        Foo::Point { x, y } => {
            _ffi_write(2 as i32, buf);
            _ffi_write(x, buf);
            _ffi_write(y, buf);
        }
        Foo::Nested(x) => {
            _ffi_write(3 as i32, buf);
            _ffi_box_Foo_to_cpp(*x, buf);
        }
    }
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_get_tests() -> _ffi_ret_ptr_2_usize {
    let ret = get_tests();
    let mut buf = Vec::<u8>::new();
    let ret_len = ret.len();
    _ffi_vec_Foo_to_cpp(ret, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    _ffi_ret_ptr_2_usize(buf_ptr, buf_cap, ret_len)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);

#[allow(non_snake_case)]
fn _ffi_vec_Foo_to_cpp(items: Vec<Foo>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_enum_Foo_to_cpp(item, buf);
    }
}
