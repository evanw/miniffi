// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"
#include <vector>

extern "C" {

int32_t _ffi_fn_check_nested(const void* buf_ptr);
void* _ffi_alloc(uintptr_t len);
uintptr_t _ffi_fn_rust_mem_leaked();
int32_t _ffi_fn_sum_tree(int32_t tree_value, const void* buf_ptr, bool has_tree_left, bool has_tree_right);

} // extern "C"

namespace {

template <typename T>
void _ffi_write(T val, std::vector<uint8_t> &buf) {
    buf.insert(buf.end(), (const uint8_t*)&val, (const uint8_t*)&val + sizeof(T));
}

void _ffi_box_i32_to_rust(int32_t val, std::vector<uint8_t>& buf) {
    _ffi_write(val, buf);
}

void _ffi_box_box_i32_to_rust(std::unique_ptr<int32_t> val, std::vector<uint8_t>& buf) {
    _ffi_box_i32_to_rust(std::move(*val), buf);
}

void _ffi_box_box_box_i32_to_rust(std::unique_ptr<std::unique_ptr<int32_t>> val, std::vector<uint8_t>& buf) {
    _ffi_box_box_i32_to_rust(std::move(*val), buf);
}

const void* _ffi_vec_to_rust(const std::vector<uint8_t>& vec) {
    return memcpy(_ffi_alloc(vec.size()), vec.data(), vec.size());
}

void _ffi_box_Tree_to_rust(rust::Tree val, std::vector<uint8_t>& buf);

void _ffi_box_Tree_to_rust(rust::Tree val, std::vector<uint8_t>& buf) {
    _ffi_write(val.value, buf);
    auto has_val_left = val.left.has_value();
    _ffi_write(has_val_left, buf);
    if (has_val_left) {
        _ffi_box_Tree_to_rust(std::move(*val.left.value()), buf);
    }
    auto has_val_right = val.right.has_value();
    _ffi_write(has_val_right, buf);
    if (has_val_right) {
        _ffi_box_Tree_to_rust(std::move(*val.right.value()), buf);
    }
}

} // namespace

bool rust::Tree::operator == (const rust::Tree& t) const {
    return (
        value == t.value &&
        (left && t.left ? **left == **t.left : !left && !t.left) &&
        (right && t.right ? **right == **t.right : !right && !t.right)
    );
}

int32_t rust::check_nested(std::unique_ptr<std::unique_ptr<std::unique_ptr<int32_t>>> x) {
    std::vector<uint8_t> buf;
    _ffi_box_box_box_i32_to_rust(std::move(*x), buf);
    auto buf_ptr = _ffi_vec_to_rust(buf);
    return _ffi_fn_check_nested(buf_ptr);
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}

int32_t rust::sum_tree(rust::Tree tree) {
    std::vector<uint8_t> buf;
    auto has_tree_left = tree.left.has_value();
    if (has_tree_left) {
        _ffi_box_Tree_to_rust(std::move(*tree.left.value()), buf);
    }
    auto has_tree_right = tree.right.has_value();
    if (has_tree_right) {
        _ffi_box_Tree_to_rust(std::move(*tree.right.value()), buf);
    }
    auto buf_ptr = _ffi_vec_to_rust(buf);
    return _ffi_fn_sum_tree(tree.value, buf_ptr, has_tree_left, has_tree_right);
}
