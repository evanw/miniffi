// This file was generated by miniffi v0.1.0. Do not edit.

#[unsafe(no_mangle)]
extern "C" fn _ffi_dealloc(ptr: *mut u8, capacity: usize) {
    drop(unsafe { Vec::from_raw_parts(ptr, 0, capacity) });
}

fn _ffi_buf_to_host(buf: Vec<u8>) -> (*const u8, usize) {
    let buf = std::mem::ManuallyDrop::new(buf);
    (buf.as_ptr(), buf.capacity())
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_check_nested() -> _ffi_ret_ptr_2_usize {
    let ret = check_nested();
    let mut buf = Vec::<u8>::new();
    let ret_len = ret.len();
    _ffi_vec_vec_i32_to_cpp(ret, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    _ffi_ret_ptr_2_usize(buf_ptr, buf_cap, ret_len)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_get_vec(n: i32) -> _ffi_ret_ptr_2_usize {
    let ret = get_vec(n);
    let mut buf = Vec::<u8>::new();
    let ret_len = ret.len();
    _ffi_vec_i32_to_cpp(ret, &mut buf);
    let (buf_ptr, buf_cap) = _ffi_buf_to_host(buf);
    _ffi_ret_ptr_2_usize(buf_ptr, buf_cap, ret_len)
}

#[unsafe(no_mangle)]
extern "C" fn _ffi_fn_rust_mem_leaked() -> usize {
    rust_mem_leaked()
}

#[repr(C)]
struct _ffi_ret_ptr_2_usize(*const u8, usize, usize);

fn _ffi_vec_i32_to_cpp(items: Vec<i32>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item, buf);
    }
}

fn _ffi_vec_vec_i32_to_cpp(items: Vec<Vec<i32>>, buf: &mut Vec<u8>) {
    for item in items {
        _ffi_write(item.len(), buf);
        _ffi_vec_i32_to_cpp(item, buf);
    }
}

fn _ffi_write<T: Copy>(val: T, buf: &mut Vec<u8>) {
    let ptr = std::ptr::addr_of!(val) as *const u8;
    let len = std::mem::size_of::<T>();
    buf.extend_from_slice(unsafe { std::slice::from_raw_parts(ptr, len) });
}
