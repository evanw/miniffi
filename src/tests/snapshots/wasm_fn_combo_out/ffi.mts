// This file was generated by miniffi v0.1.0. Do not edit.

export async function instantiate(bytes: BufferSource, imports?: WebAssembly.ModuleImports): Promise<{ memory: WebAssembly.Memory }> {
    let env = Object.assign({}, imports, _ffi_imports);
    let promise = WebAssembly.instantiate(bytes, { env });
    _ffi_exports = (await promise).instance.exports as any;
    return { memory: _ffi_exports.memory };
}

export async function instantiateStreaming(source: Response | PromiseLike<Response>, imports?: WebAssembly.ModuleImports): Promise<{ memory: WebAssembly.Memory }> {
    let env = Object.assign({}, imports, _ffi_imports);
    let promise = WebAssembly.instantiateStreaming(source, { env });
    _ffi_exports = (await promise).instance.exports as any;
    return { memory: _ffi_exports.memory };
}

export interface Foo {
    x: [Bar, Bar[]],
    y: [undefined, [number], [number, boolean]][],
}

export interface Bar {
    x: number,
    y: Foo[],
}

export function rust_mem_leaked(): number {
    return _ffi_exports._ffi_fn_rust_mem_leaked();
}

export function check_combo1(): Foo {
    let multi_ret = _ffi_exports._ffi_fn_check_combo1();
    let ret_x_0_x = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_ptr = _ffi_dv.getInt32(multi_ret + 4, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 8, true);
    let ret_x_0_y_len = _ffi_dv.getUint32(multi_ret + 12, true);
    let ret_x_1_len = _ffi_dv.getUint32(multi_ret + 16, true);
    let ret_y_len = _ffi_dv.getUint32(multi_ret + 20, true);
    let buf = _ffi_new_ReadBuf(buf_ptr);
    let ret: Foo = {
        x: [
            { x: ret_x_0_x, y: _ffi_vec_Foo_from_rust(ret_x_0_y_len, buf) },
            _ffi_vec_Bar_from_rust(ret_x_1_len, buf)
        ],
        y: _ffi_vec__i32_f32_bool_from_rust(ret_y_len, buf)
    };
    _ffi_exports._ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

export function check_combo2(): Foo {
    let multi_ret = _ffi_exports._ffi_fn_check_combo2();
    let ret_x_0_x = _ffi_update_dv().getInt32(multi_ret, true);
    let buf_ptr = _ffi_dv.getInt32(multi_ret + 4, true);
    let buf_cap = _ffi_dv.getUint32(multi_ret + 8, true);
    let ret_x_0_y_len = _ffi_dv.getUint32(multi_ret + 12, true);
    let ret_x_1_len = _ffi_dv.getUint32(multi_ret + 16, true);
    let ret_y_len = _ffi_dv.getUint32(multi_ret + 20, true);
    let buf = _ffi_new_ReadBuf(buf_ptr);
    let ret: Foo = {
        x: [
            { x: ret_x_0_x, y: _ffi_vec_Foo_from_rust(ret_x_0_y_len, buf) },
            _ffi_vec_Bar_from_rust(ret_x_1_len, buf)
        ],
        y: _ffi_vec__i32_f32_bool_from_rust(ret_y_len, buf)
    };
    _ffi_exports._ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

let _ffi_dv: DataView;
let _ffi_new_ReadBuf = (off: number): _ffi_ReadBuf => ({ dv: _ffi_update_dv(), off });

interface _ffi_ReadBuf {
    dv: DataView,
    off: number,
}

function _ffi_update_dv(): DataView {
    let buffer = _ffi_exports.memory.buffer;
    if (!_ffi_dv || _ffi_dv.buffer !== buffer) _ffi_dv = new DataView(buffer);
    return _ffi_dv;
}

function _ffi_read_f32(buf: _ffi_ReadBuf): number {
    let val = buf.dv.getFloat32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_i32(buf: _ffi_ReadBuf): number {
    let val = buf.dv.getInt32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_u32(buf: _ffi_ReadBuf): number {
    let val = buf.dv.getUint32(buf.off, true);
    buf.off += 4;
    return val;
}

function _ffi_read_u8(buf: _ffi_ReadBuf): number {
    return buf.dv.getUint8(buf.off++);
}

function _ffi_vec_Bar_from_rust(len: number, buf: _ffi_ReadBuf): Bar[] {
    let items: Bar[] = [];
    while (items.length < len) {
        items.push({ x: _ffi_read_i32(buf), y: _ffi_vec_Foo_from_rust(_ffi_read_u32(buf), buf) });
    }
    return items;
}

function _ffi_vec_Foo_from_rust(len: number, buf: _ffi_ReadBuf): Foo[] {
    let items: Foo[] = [];
    while (items.length < len) {
        items.push({
            x: [
                { x: _ffi_read_i32(buf), y: _ffi_vec_Foo_from_rust(_ffi_read_u32(buf), buf) },
                _ffi_vec_Bar_from_rust(_ffi_read_u32(buf), buf)
            ],
            y: _ffi_vec__i32_f32_bool_from_rust(_ffi_read_u32(buf), buf)
        });
    }
    return items;
}

function _ffi_vec__i32_f32_bool_from_rust(len: number, buf: _ffi_ReadBuf): [undefined, [number], [number, boolean]][] {
    let items: [undefined, [number], [number, boolean]][] = [];
    while (items.length < len) {
        items.push([undefined, [_ffi_read_i32(buf)], [_ffi_read_f32(buf), !!_ffi_read_u8(buf)]]);
    }
    return items;
}

let _ffi_exports: {
    memory: WebAssembly.Memory,
    _ffi_dealloc: (ptr: number, capacity: number) => void,
    _ffi_fn_check_combo1: () => number,
    _ffi_fn_check_combo2: () => number,
    _ffi_fn_rust_mem_leaked: () => number,
};

const _ffi_imports = {};
