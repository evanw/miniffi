// This file was generated by miniffi v0.1.0. Do not edit.

#include "ffi.h"

struct _ffi_ret_ptr_2_usize {
    const void* _0;
    uintptr_t _1;
    uintptr_t _2;
};

extern "C" {

void _ffi_dealloc(const void* ptr, uintptr_t capacity);
_ffi_ret_ptr_2_usize _ffi_fn_check_nested();
_ffi_ret_ptr_2_usize _ffi_fn_get_vec(int32_t n);
uintptr_t _ffi_fn_rust_mem_leaked();

} // extern "C"

namespace {

template <typename T>
T _ffi_read(const uint8_t* &ptr) {
    T val;
    memcpy(&val, ptr, sizeof(T));
    ptr += sizeof(T);
    return val;
}

std::vector<int32_t> _ffi_vec_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<int32_t> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item = _ffi_read<int32_t>(end);
        items.emplace_back(item);
    }
    return items;
}

std::vector<std::vector<int32_t>> _ffi_vec_vec_i32_from_rust(uintptr_t len, const uint8_t*& end) {
    std::vector<std::vector<int32_t>> items;
    items.reserve(len);
    while (items.size() < len) {
        auto item_len = _ffi_read<uintptr_t>(end);
        auto item = _ffi_vec_i32_from_rust(item_len, end);
        items.emplace_back(std::move(item));
    }
    return items;
}

} // namespace

std::vector<std::vector<int32_t>> rust::check_nested() {
    auto multi_ret = _ffi_fn_check_nested();
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_len = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret = _ffi_vec_vec_i32_from_rust(ret_len, buf_end);
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

std::vector<int32_t> rust::get_vec(int32_t n) {
    auto multi_ret = _ffi_fn_get_vec(n);
    auto buf_ptr = multi_ret._0;
    auto buf_cap = multi_ret._1;
    auto ret_len = multi_ret._2;
    auto buf_end = (const uint8_t*)buf_ptr;
    auto ret = _ffi_vec_i32_from_rust(ret_len, buf_end);
    _ffi_dealloc(buf_ptr, buf_cap);
    return ret;
}

uintptr_t rust::rust_mem_leaked() {
    return _ffi_fn_rust_mem_leaked();
}
